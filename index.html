<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Criador de Cartões Estilo RPG</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;800&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="animation.css">
    <script src="animation.js"></script>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="shield.png">
    <style>
        /* O contêiner principal com o efeito */
        .nebula-sky {
            position: relative;
            width: 100%;
            max-width: 600px;
            /* Largura máxima para a demonstração */
            height: 100%;
            border-radius: 1.5rem;
            /* Cantos bem arredondados */
            overflow: hidden;
            /* ESSENCIAL para conter o efeito */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5),
                inset 0 0 1px 1px rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background-color: transparent;
            /* Fundo preto base */

            /* Habilita transformações 3D para os filhos e suaviza o movimento */
            transform-style: preserve-3d;
            transition: transform 0.2s ease-out;
            /* Transição mais suave para o retorno */
            cursor: grab;
            /* Indica que o elemento é arrastável */
        }

        .nebula-sky:active {
            cursor: grabbing;
            /* Muda o cursor ao clicar */
        }

        /* Contêiner para as camadas de paralaxe */
        .parallax-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* Garante que as estrelas também fiquem no espaço 3D */
            transform-style: preserve-3d;
        }

        /* Estilo base para todas as camadas de estrelas */
        .stars-layer {
            position: absolute;
            top: -25%;
            left: -25%;
            /* Expandido para não mostrar bordas ao mover */
            width: 150%;
            height: 150%;
            background-repeat: repeat;
            transition: transform 0.2s ease-out;
            /* Suaviza o movimento do paralaxe */
        }

        /* Camada de brilho que segue o mouse */
        #glow-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.15), transparent 40%);
            opacity: 0;
            transition: opacity 0.2s ease-out;
            pointer-events: none;
            /* Garante que não interfira com o mouse */
        }

        .nebula-sky:active #glow-overlay {
            opacity: 1;
        }

        /* Camada da Nebulosa (plano de fundo principal) */
        /* Camada da Nebulosa (plano de fundo principal) - BASEADO NA IMAGEM */
        #nebula-bg {
            background-image:
                /* 2. Nuvem de ciano/verde brilhante (canto superior) */
                radial-gradient(ellipse at 40% 25%, rgb(7 82 131 / 72%) 0%, transparent 60%),
                /* 3. Nuvem magenta/rosa vibrante (canto inferior direito) */
                radial-gradient(ellipse at 80% 65%, rgba(244, 63, 226, 0.4) 0%, transparent 60%),
                /* 4. Base de azul profundo (canto superior esquerdo) */
                radial-gradient(ellipse at 25% 30%, rgb(8 36 71) 0%, transparent 70%),
                /* 5. Base de púrpura/magenta escura (parte inferior) */
                radial-gradient(ellipse at 50% 85%, rgba(190, 24, 154, 0.5) 0%, transparent 70%),
                /* 6. Toque de verde escuro no canto superior esquerdo */
                radial-gradient(ellipse at 10% 15%, rgb(84 93 21 / 50%) 0%, transparent 60%);

            /* Move a nebulosa para trás no espaço 3D */
            transform: translateZ(-50px);
        }

        /* Camadas de estrelas e a faixa da Via Láctea */
        #stars-far,
        #stars-medium,
        #stars-near,
        #milky-way {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* NOVO: Faixa da Via Láctea */
        #milky-way {

            transform: translateZ(-50px) rotateZ(-35deg);
            /* Posição e rotação da faixa */
        }



        /* ============================================== */
        /* == VERSÃO COM DENSIDADE DE ESTRELAS AUMENTADA == */
        /* ============================================== */

        /* Camada de estrelas distantes (MUITO MAIS ESTRELAS) */
        #stars-far {
            background-image:
                radial-gradient(1px 1px at 73% 8%, white, transparent), radial-gradient(1px 1px at 28% 5%, white, transparent),
                radial-gradient(1px 1px at 93% 18%, rgba(255, 255, 255, 0.7), transparent), radial-gradient(1px 1px at 15% 9%, rgba(255, 255, 255, 0.8), transparent),
                radial-gradient(1px 1px at 38% 85%, rgba(255, 255, 255, 0.7), transparent), radial-gradient(1px 1px at 6% 77%, rgba(255, 255, 255, 0.8), transparent),
                radial-gradient(1px 1px at 58% 58%, white, transparent), radial-gradient(1px 1px at 83% 73%, rgba(255, 255, 255, 0.7), transparent),
                radial-gradient(1px 1px at 23% 93%, white, transparent), radial-gradient(1px 1px at 43% 98%, rgba(255, 255, 255, 0.7), transparent),
                radial-gradient(1px 1px at 88% 3%, rgba(255, 255, 255, 0.8), transparent), radial-gradient(1px 1px at 53% 93%, rgba(255, 255, 255, 0.7), transparent),
                radial-gradient(1px 1px at 19% 49%, rgba(255, 255, 255, 0.8), transparent), radial-gradient(1px 1px at 63% 68%, white, transparent),
                radial-gradient(1px 1px at 48% 28%, rgba(255, 255, 255, 0.7), transparent), radial-gradient(1px 1px at 83% 13%, rgba(255, 255, 255, 0.8), transparent),
                radial-gradient(1px 1px at 28% 68%, white, transparent), radial-gradient(1px 1px at 53% 13%, rgba(255, 255, 255, 0.7), transparent),
                radial-gradient(1px 1px at 8% 33%, rgba(255, 255, 255, 0.8), transparent), radial-gradient(1px 1px at 98% 83%, white, transparent),
                radial-gradient(1px 1px at 38% 53%, rgba(255, 255, 255, 0.7), transparent), radial-gradient(1px 1px at 68% 73%, rgba(255, 255, 255, 0.8), transparent),
                radial-gradient(1px 1px at 10% 20%, white, transparent), radial-gradient(1px 1px at 85% 15%, white, transparent),
                radial-gradient(1px 1px at 55% 75%, rgba(255, 255, 255, 0.7), transparent), radial-gradient(1px 1px at 95% 45%, rgba(255, 255, 255, 0.8), transparent),
                radial-gradient(1px 1px at 45% 5%, rgba(255, 255, 255, 0.7), transparent), radial-gradient(1px 1px at 5% 55%, rgba(255, 255, 255, 0.8), transparent),
                radial-gradient(1px 1px at 30% 35%, white, transparent), radial-gradient(1px 1px at 70% 60%, rgba(255, 255, 255, 0.7), transparent),
                radial-gradient(1px 1px at 20% 80%, white, transparent), radial-gradient(1px 1px at 5% 90%, rgba(255, 255, 255, 0.7), transparent),
                radial-gradient(1px 1px at 75% 5%, rgba(255, 255, 255, 0.8), transparent), radial-gradient(1px 1px at 90% 95%, rgba(255, 255, 255, 0.7), transparent),
                radial-gradient(1px 1px at 15% 40%, rgba(255, 255, 255, 0.8), transparent), radial-gradient(1px 1px at 60% 85%, white, transparent),
                radial-gradient(1px 1px at 40% 25%, rgba(255, 255, 255, 0.7), transparent), radial-gradient(1px 1px at 80% 5%, rgba(255, 255, 255, 0.8), transparent),
                radial-gradient(1px 1px at 25% 65%, white, transparent), radial-gradient(1px 1px at 50% 10%, rgba(255, 255, 255, 0.7), transparent),
                radial-gradient(1px 1px at 5% 30%, rgba(255, 255, 255, 0.8), transparent), radial-gradient(1px 1px at 95% 80%, white, transparent),
                radial-gradient(1px 1px at 35% 50%, rgba(255, 255, 255, 0.7), transparent), radial-gradient(1px 1px at 65% 70%, rgba(255, 255, 255, 0.8), transparent),
                radial-gradient(1px 1px at 18% 70%, white, transparent), radial-gradient(1px 1px at 78% 25%, white, transparent),
                radial-gradient(1px 1px at 65% 85%, rgba(255, 255, 255, 0.7), transparent), radial-gradient(1px 1px at 88% 55%, rgba(255, 255, 255, 0.8), transparent),
                radial-gradient(1px 1px at 33% 15%, rgba(255, 255, 255, 0.7), transparent), radial-gradient(1px 1px at 12% 42%, rgba(255, 255, 255, 0.8), transparent),
                radial-gradient(1px 1px at 48% 48%, white, transparent), radial-gradient(1px 1px at 72% 88%, rgba(255, 255, 255, 0.7), transparent),
                radial-gradient(1px 1px at 22% 95%, white, transparent), radial-gradient(1px 1px at 3% 80%, rgba(255, 255, 255, 0.7), transparent),
                radial-gradient(1px 1px at 82% 10%, rgba(255, 255, 255, 0.8), transparent), radial-gradient(1px 1px at 98% 88%, rgba(255, 255, 255, 0.7), transparent),
                radial-gradient(1px 1px at 50% 50%, white, transparent), radial-gradient(1px 1px at 1% 1%, white, transparent),
                radial-gradient(1px 1px at 99% 99%, rgba(255, 255, 255, 0.7), transparent), radial-gradient(1px 1px at 1% 99%, rgba(255, 255, 255, 0.8), transparent),
                radial-gradient(1px 1px at 99% 1%, rgba(255, 255, 255, 0.7), transparent), radial-gradient(1px 1px at 25% 25%, rgba(255, 255, 255, 0.8), transparent),
                radial-gradient(1px 1px at 75% 75%, white, transparent), radial-gradient(1px 1px at 25% 75%, rgba(255, 255, 255, 0.7), transparent),
                radial-gradient(1px 1px at 75% 25%, white, transparent), radial-gradient(1px 1px at 50% 0%, rgba(255, 255, 255, 0.7), transparent),
                radial-gradient(1px 1px at 0% 50%, rgba(255, 255, 255, 0.8), transparent), radial-gradient(1px 1px at 100% 50%, rgba(255, 255, 255, 0.7), transparent),
                radial-gradient(1px 1px at 50% 100%, rgba(255, 255, 255, 0.8), transparent), radial-gradient(1px 1px at 0% 0%, white, transparent),
                radial-gradient(1px 1px at 100% 100%, rgba(255, 255, 255, 0.7), transparent), radial-gradient(1px 1px at 0% 100%, rgba(255, 255, 255, 0.8), transparent),
                radial-gradient(1px 1px at 100% 0%, white, transparent);
            background-size: 200px 200px;
            /* Reduzido para aumentar a densidade aparente */
            transform: translateZ(-40px);
        }

        /* Camada de estrelas médias (MUITO MAIS ESTRELAS) */
        #stars-medium {
            background-image:
                radial-gradient(2px 2px at 15% 95%, rgba(255, 255, 255, 0.9), transparent), radial-gradient(2px 2px at 45% 55%, white, transparent),
                radial-gradient(2px 2px at 80% 90%, rgba(255, 255, 255, 0.9), transparent), radial-gradient(2px 2px at 65% 25%, white, transparent),
                radial-gradient(2px 2px at 25% 10%, rgba(255, 255, 255, 0.8), transparent), radial-gradient(2px 2px at 5% 30%, white, transparent),
                radial-gradient(2px 2px at 95% 65%, rgba(255, 255, 255, 0.9), transparent), radial-gradient(2px 2px at 35% 75%, white, transparent),
                radial-gradient(2px 2px at 55% 15%, rgba(255, 255, 255, 0.8), transparent), radial-gradient(2px 2px at 85% 40%, white, transparent),
                radial-gradient(2px 2px at 5% 70%, rgba(255, 255, 255, 0.9), transparent), radial-gradient(2px 2px at 50% 85%, white, transparent),
                radial-gradient(2px 2px at 70% 5%, rgba(255, 255, 255, 0.8), transparent), radial-gradient(2px 2px at 90% 20%, rgba(255, 255, 255, 0.9), transparent),
                radial-gradient(2px 2px at 20% 50%, rgba(255, 255, 255, 0.9), transparent), radial-gradient(2px 2px at 50% 30%, white, transparent),
                radial-gradient(2px 2px at 85% 70%, rgba(255, 255, 255, 0.9), transparent), radial-gradient(2px 2px at 60% 5%, white, transparent),
                radial-gradient(2px 2px at 30% 20%, rgba(255, 255, 255, 0.8), transparent), radial-gradient(2px 2px at 10% 80%, white, transparent),
                radial-gradient(2px 2px at 40% 5%, rgba(255, 255, 255, 0.9), transparent), radial-gradient(2px 2px at 70% 35%, white, transparent),
                radial-gradient(2px 2px at 95% 80%, rgba(255, 255, 255, 0.9), transparent), radial-gradient(2px 2px at 10% 45%, white, transparent),
                radial-gradient(2px 2px at 30% 90%, rgba(255, 255, 255, 0.8), transparent), radial-gradient(2px 2px at 80% 50%, white, transparent);
            background-size: 300px 300px;
            /* Reduzido para aumentar a densidade aparente */
            transform: translateZ(-20px);
        }

        /* Camada de estrelas próximas (MUITO MAIS ESTRELAS) */
        #stars-near {
            background-image:
                radial-gradient(3px 3px at 5% 5%, rgba(255, 255, 255, 0.8), transparent), radial-gradient(3px 3px at 92% 72%, rgba(255, 255, 255, 0.7), transparent),
                radial-gradient(3px 3px at 50% 40%, white, transparent), radial-gradient(3px 3px at 20% 60%, white, transparent),
                radial-gradient(3px 3px at 70% 20%, rgba(255, 255, 255, 0.8), transparent), radial-gradient(3px 3px at 30% 90%, white, transparent),
                radial-gradient(3px 3px at 85% 5%, rgba(255, 255, 255, 0.7), transparent), radial-gradient(3px 3px at 15% 80%, white, transparent),
                radial-gradient(3px 3px at 60% 50%, rgba(255, 255, 255, 0.8), transparent), radial-gradient(3px 3px at 40% 10%, white, transparent),
                radial-gradient(3px 3px at 35% 25%, white, transparent), radial-gradient(3px 3px at 75% 85%, white, transparent),
                radial-gradient(3px 3px at 95% 30%, rgba(255, 255, 255, 0.7), transparent), radial-gradient(3px 3px at 5% 45%, white, transparent),
                radial-gradient(3px 3px at 55% 70%, rgba(255, 255, 255, 0.8), transparent),
                radial-gradient(3px 3px at 25% 35%, rgba(255, 255, 255, 0.8), transparent), radial-gradient(3px 3px at 82% 52%, rgba(255, 255, 255, 0.7), transparent),
                radial-gradient(3px 3px at 40% 70%, white, transparent), radial-gradient(3px 3px at 10% 20%, white, transparent),
                radial-gradient(3px 3px at 60% 80%, rgba(255, 255, 255, 0.8), transparent);
            background-size: 400px 400px;
            /* Reduzido para aumentar a densidade aparente */
            transform: translateZ(0px);
        }

        /* Estilo do texto */
        .content {
            position: relative;
            z-index: 10;
            padding: 2rem;
            color: white;
            font-size: 2rem;
            font-weight: bold;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.7);
            /* Coloca o texto um pouco à frente para acentuar o 3D */
            transform: translateZ(20px);
        }
    </style>
</head>

<body class="min-h-screen flex flex-col items-center">
    <audio id="background-music" loop autoplay>
        <source src="fundo.mp3" type="audio/mpeg">
    </audio>

    <input type="file" id="jsonImportInput" class="hidden" accept=".json">

    <div id="splashScreen" class="splash-screen">
        <svg xmlns="http://www.w3.org/2000/svg" class="loading-icon text-indigo-400 w-20 h-20" viewBox="0 0 24 24"
            fill="currentColor">
            <defs>
                <clipPath id="loaderClipPath">
                    <rect id="loaderClipRect" x="0" y="0" width="24" height="0" />
                </clipPath>
            </defs>
            <g clip-path="url(#loaderClipPath)">
                <rect x="5" y="2" width="14" height="20" rx="2" ry="2" fill="none" stroke="currentColor"
                    stroke-width="2" />
                <path
                    d="M12 7.74l1.39 2.82 3.12.45-2.26 2.2.53 3.11-2.78-1.46-2.78 1.46.53-3.11-2.26-2.2 3.12.45L12 7.74z"
                    fill="currentColor" />
            </g>
        </svg>
        <h1 class="text-3xl font-bold mt-4">Forjando Cartões...</h1>
        <p id="progressText" class="text-sm mt-2 font-medium progress-text">Preparando...</p>
        <div class="absolute inset-0"></div>
    </div>

    <div id="mainContent" class="w-full max-w-5xl hidden p-4">
        <div id="share-section" class="hidden">
            <div class="bg-slate-800 text-white p-6 rounded-3xl shadow-2xl space-y-6">

                <div id="my-cards-to-share" class="mb-8">
                    <h3 class="text-xl font-bold text-indigo-300 mb-4 text-center">Meus Cards para Compartilhar</h3>
                    <p class="text-center text-gray-400 text-sm mb-6">Clique em um card abaixo para adicioná-lo ou
                        removê-lo do mercado.</p>

                    <div>
                        <h4 class="text-lg font-semibold text-gray-300 mb-2">Personagens</h4>
                        <div id="my-characters-list"
                            class="flex gap-4 p-2 bg-gray-900/50 rounded-lg overflow-x-auto share-list-container">
                        </div>
                    </div>
                    <div class="mt-4">
                        <h4 class="text-lg font-semibold text-gray-300 mb-2">Magias & Habilidades</h4>
                        <div id="my-spells-list"
                            class="flex gap-4 p-2 bg-gray-900/50 rounded-lg overflow-x-auto share-list-container">
                        </div>
                    </div>
                    <div class="mt-4">
                        <h4 class="text-lg font-semibold text-gray-300 mb-2">Itens</h4>
                        <div id="my-items-list"
                            class="flex gap-4 p-2 bg-gray-900/50 rounded-lg overflow-x-auto share-list-container">
                        </div>
                    </div>
                </div>

                <div class="border-t-2 border-gray-700 my-6"></div>

                <div class="text-center">
                    <h2 class="text-2xl font-bold text-green-400">Mercado de Cards</h2>
                    <p class="text-gray-400 mt-1">Veja os cards compartilhados por outros aventureiros. Clique para
                        pegar!</p>
                </div>
                <div id="market-sections" class="space-y-8">
                    <div>
                        <h3 class="text-xl font-bold text-indigo-400 mb-4 border-b-2 border-indigo-400/50 pb-2">
                            Personagens no Mercado</h3>
                        <div id="market-characters-list" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                            <p class="text-gray-500 col-span-full text-center">Carregando...</p>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-bold text-teal-400 mb-4 border-b-2 border-teal-400/50 pb-2">Magias no
                            Mercado</h3>
                        <div id="market-spells-list" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                            <p class="text-gray-500 col-span-full text-center">Carregando...</p>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-bold text-amber-400 mb-4 border-b-2 border-amber-400/50 pb-2">Itens à
                            Venda</h3>
                        <div id="market-paid-items-list" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                            <p class="text-gray-500 col-span-full text-center">Carregando...</p>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-bold text-gray-400 mb-4 border-b-2 border-gray-400/50 pb-2">Itens
                            Gratuitos</h3>
                        <div id="market-free-items-list" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                            <p class="text-gray-500 col-span-full text-center">Carregando...</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="creation-section" class="hidden">
            <div class="bg-slate-800 text-white p-6 rounded-3xl shadow-2xl">
                <div class="flex justify-between items-center mb-6">
                    <h2 id="form-title" class="text-2xl font-bold text-indigo-300">Novo Cartão de Personagem</h2>
                    <button class="back-btn text-gray-400 hover:text-white transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24"
                            stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>
                <form id="cardForm" class="space-y-6">
                    <div>
                        <label for="cardTitle" class="block text-sm font-semibold mb-1">Nome</label>
                        <input type="text" id="cardTitle" placeholder="Ex: Guerreiro Lendário" required
                            class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600">
                    </div>
                    <div>
                        <label for="cardSubTitle" class="block text-sm font-semibold mb-1">Raça e Classe</label>
                        <input type="text" id="cardSubTitle" placeholder="Ex: Humano Mago" required
                            class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600">
                    </div>
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label for="cardLevel" class="block text-sm font-semibold mb-1">Nível</label>
                            <input type="card3d" id="cardLevel" placeholder="1" required
                                class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600">
                        </div>
                        <div>
                            <label for="dinheiro" class="block text-sm font-semibold mb-1">Dinheiro</label>
                            <input type="number" id="dinheiro" placeholder="0"
                                class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600">
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-bold text-indigo-300 mb-2">Imagem do Personagem</h3>
                        <div class="mt-4 text-center">
                            <label for="characterImageUpload"
                                class="block text-sm font-semibold mb-1 cursor-pointer">Faça upload de uma
                                imagem:</label>
                            <input type="file" id="characterImageUpload" accept="image/*" class="file-upload-input">
                            <img id="characterImagePreview"
                                class="mt-4 mx-auto w-32 h-32 object-cover rounded-full border-4 border-gray-600 hidden"
                                alt="Pré-visualização do Personagem">
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-bold text-indigo-300 mb-2">Imagem de Fundo</h3>
                        <div class="mt-4 text-center">
                            <label for="backgroundImageUpload"
                                class="block text-sm font-semibold mb-1 cursor-pointer">Faça upload de uma
                                imagem:</label>
                            <input type="file" id="backgroundImageUpload" accept="image/*" class="file-upload-input">
                            <div id="backgroundImagePreview"
                                class="mt-4 mx-auto w-full h-48 rounded-lg border-4 border-gray-600 hidden bg-cover bg-center">
                            </div>
                        </div>
                    </div>
                    <div class="grid grid-cols-2 gap-4">
                        <h3 class="col-span-2 text-xl font-bold text-indigo-300">Status de Combate</h3>
                        <div><label for="vida" class="block text-sm font-semibold mb-1">Vida Máx. (PV)</label><input
                                type="number" id="vida" placeholder="1"
                                class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600"></div>
                        <div><label for="mana" class="block text-sm font-semibold mb-1">Mana Máx. (PM)</label><input
                                type="number" id="mana" placeholder="1"
                                class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600"></div>
                        <div><label for="vidaAtual" class="block text-sm font-semibold mb-1">Vida Atual</label><input
                                type="number" id="vidaAtual" placeholder="1"
                                class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600"></div>
                        <div><label for="manaAtual" class="block text-sm font-semibold mb-1">Mana Atual</label><input
                                type="number" id="manaAtual" placeholder="1"
                                class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600"></div>
                        <div><label for="armadura" class="block text-sm font-semibold mb-1">Armadura</label><input
                                type="number" id="armadura" placeholder="0"
                                class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600"></div>
                        <div><label for="esquiva" class="block text-sm font-semibold mb-1">Esquiva</label><input
                                type="number" id="esquiva" placeholder="0"
                                class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600"></div>
                        <div><label for="bloqueio" class="block text-sm font-semibold mb-1">Bloqueio</label><input
                                type="number" id="bloqueio" placeholder="0"
                                class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600"></div>
                        <div><label for="deslocamento"
                                class="block text-sm font-semibold mb-1">Deslocamento</label><input type="number"
                                id="deslocamento" placeholder="0"
                                class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600"></div>
                    </div>
                    <div class="grid grid-cols-2 gap-4">
                        <h3 class="col-span-2 text-xl font-bold text-indigo-300">Atributos Principais</h3>
                        <div><label for="agilidade" class="block text-sm font-semibold mb-1">Agilidade
                                (AGI)</label><input type="number" id="agilidade" placeholder="1"
                                class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600"></div>
                        <div><label for="carisma" class="block text-sm font-semibold mb-1">Carisma (CAR)</label><input
                                type="number" id="carisma" placeholder="1"
                                class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600"></div>
                        <div><label for="forca" class="block text-sm font-semibold mb-1">Força (FOR)</label><input
                                type="number" id="forca" placeholder="1"
                                class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600"></div>
                        <div><label for="inteligencia" class="block text-sm font-semibold mb-1">Inteligência
                                (INT)</label><input type="number" id="inteligencia" placeholder="1"
                                class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600"></div>
                        <div><label for="sabedoria" class="block text-sm font-semibold mb-1">Sabedoria
                                (SAB)</label><input type="number" id="sabedoria" placeholder="1"
                                class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600"></div>
                        <div><label for="vigor" class="block text-sm font-semibold mb-1">Vigor (VIG)</label><input
                                type="number" id="vigor" placeholder="1"
                                class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600"></div>
                    </div>
                    <div>
                        <h3 class="text-xl font-bold text-indigo-300 mb-2">Detalhes do Personagem</h3>
                        <div class="space-y-4">
                            <div>
                                <label for="historia" class="block text-sm font-semibold mb-1">História</label>
                                <textarea id="historia" rows="4" placeholder="A jornada do personagem até agora..."
                                    class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600"></textarea>
                            </div>
                            <div>
                                <label for="personalidade"
                                    class="block text-sm font-semibold mb-1">Personalidade</label>
                                <textarea id="personalidade" rows="3"
                                    placeholder="Traços, manias, e como o personagem se comporta..."
                                    class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600"></textarea>
                            </div>
                            <div>
                                <label for="motivacao" class="block text-sm font-semibold mb-1">Motivação</label>
                                <textarea id="motivacao" rows="3"
                                    placeholder="O que impulsiona o personagem em sua aventura?"
                                    class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600"></textarea>
                            </div>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-bold text-indigo-300 mb-2">Perícias</h3>
                        <div id="pericias-checkboxes-container" class="space-y-2"></div>
                        <div id="pericia-description-display" class="mt-4 p-4 rounded-lg bg-gray-700 hidden">
                            <h4 id="periciaDescriptionTitle" class="font-bold text-indigo-300"></h4>
                            <p id="periciaDescriptionText" class="text-sm text-gray-300 mt-2"></p>
                        </div>
                    </div>
                    <button type="submit" id="submitButton"
                        class="w-full py-3 px-4 rounded-full text-lg font-bold text-white bg-gradient-to-r from-indigo-500 to-purple-600 hover:from-indigo-600 hover:to-purple-700 focus:outline-none transition duration-300 ease-in-out transform hover:scale-105 shadow-xl btn-gradient-pulse">
                        Criar Cartão
                    </button>
                </form>
            </div>
        </div>

        <div id="display-section">
            <div id="thumbnail-list" class="flex flex-wrap gap-4 p-4 bg-gray-900/50 rounded-xl shadow-inner mb-4">
                <p class="text-gray-500">Nenhum cartão salvo ainda. Crie um para começar!</p>
            </div>
            <div id="card-display-area" class="w-full max-w-lg mx-auto mb-1 items-center justify-center"
                style="min-height: 720px;">
                <p class="text-gray-400">Selecione um personagem na lista acima para ver os detalhes.</p>
            </div>
        </div>

        <div id="spell-creation-section" class="hidden">
            <div class="bg-slate-800 text-white p-6 rounded-3xl shadow-2xl">
                <div class="flex justify-between items-center mb-6">
                    <h2 id="spell-form-title" class="text-2xl font-bold text-teal-300">Nova Magia/Habilidade</h2>
                    <button class="back-btn text-gray-400 hover:text-white transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24"
                            stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>
                <form id="spellForm" class="space-y-6">
                    <div>
                        <label for="spellType" class="block text-sm font-semibold mb-1">Tipo</label>
                        <select id="spellType"
                            class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600">
                            <option value="magia">Magia</option>
                            <option value="habilidade">Habilidade</option>
                        </select>
                    </div>
                    <div>
                        <h3 class="text-xl font-bold text-teal-300 mb-2">Ícone</h3>
                        <div class="mt-4 text-center">
                            <label for="spellImageUpload" class="block text-sm font-semibold mb-1 cursor-pointer">Faça
                                upload de uma imagem:</label>
                            <input type="file" id="spellImageUpload" accept="image/*" class="file-upload-input">
                            <img id="spellImagePreview"
                                class="mt-4 mx-auto w-32 h-32 object-cover rounded-full border-4 border-gray-600 hidden"
                                alt="Pré-visualização da Magia">
                        </div>
                    </div>
                    <div><label for="spellName" class="block text-sm font-semibold mb-1">Nome</label><input type="text"
                            id="spellName" placeholder="Ex: Curar Ferimentos 1° Círculo" required
                            class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600"></div>
                    <div><label for="spellExecution" class="block text-sm font-semibold mb-1">Execução</label><input
                            type="text" id="spellExecution" placeholder="Ex: padrão"
                            class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600"></div>
                    <div><label for="spellRange" class="block text-sm font-semibold mb-1">Alcance</label><input
                            type="text" id="spellRange" placeholder="Ex: toque"
                            class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600"></div>
                    <div><label for="spellTarget" class="block text-sm font-semibold mb-1">Alvo</label><input
                            type="text" id="spellTarget" placeholder="Ex: 1 ser"
                            class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600"></div>
                    <div><label for="spellDuration" class="block text-sm font-semibold mb-1">Duração</label><input
                            type="text" id="spellDuration" placeholder="Ex: instantânea"
                            class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600"></div>
                    <div><label for="spellResistencia"
                            class="block text-sm font-semibold mb-1">Resistência</label><input type="text"
                            id="spellResistencia" placeholder="Ex: instantânea"
                            class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600"></div>
                    <div><label for="spellDescription"
                            class="block text-sm font-semibold mb-1">Descrição</label><textarea id="spellDescription"
                            rows="4" placeholder="Ex: Você canaliza energia positiva para curar..."
                            class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600"></textarea>
                    </div>
                    <div><label for="spellEnhance" class="block text-sm font-semibold mb-1">Aprimorar</label><textarea
                            id="spellEnhance" rows="3" placeholder="Ex: (+2 PM): A cura aumenta para 2d10+2..."
                            class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600"></textarea>
                    </div>
                    <div><label for="spellTrue" class="block text-sm font-semibold mb-1">Verdadeiro</label><textarea
                            id="spellTrue" rows="3" placeholder="Ex: (+9 PM): muda o alcance para 'curto'..."
                            class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600"></textarea>
                    </div>
                    <button type="submit" id="spellSubmitButton"
                        class="w-full py-3 px-4 rounded-full text-lg font-bold text-white bg-gradient-to-r from-teal-500 to-cyan-600 hover:from-teal-600 hover:to-cyan-700 focus:outline-none transition duration-300 ease-in-out transform hover:scale-105 shadow-xl">
                        Salvar
                    </button>
                </form>
            </div>
        </div>

        <div id="spell-display-section" class="hidden">
            <div id="spell-thumbnail-list" class="flex flex-wrap gap-4 p-4 bg-gray-900/50 rounded-xl shadow-inner mb-4">
                <p class="text-gray-500">Nenhuma magia/habilidade salva ainda. Crie uma para começar!</p>
            </div>
            <div id="spell-thumbnail-list-hab"
                class="flex flex-wrap gap-4 p-4 bg-gray-900/50 rounded-xl shadow-inner mb-4">
                <p class="text-gray-500">Nenhuma magia/habilidade salva ainda. Crie uma para começar!</p>
            </div>
            <div id="spell-card-display-area" class="w-full max-w-lg mx-auto mb-1 items-center justify-center"
                style="min-height: 720px;">
                <p class="text-gray-400">Selecione uma magia ou habilidade na lista acima para ver os detalhes.</p>
            </div>
        </div>

        <div id="item-creation-section" class="hidden">
            <div class="bg-slate-800 text-white p-6 rounded-3xl shadow-2xl">
                <div class="flex justify-between items-center mb-6">
                    <h2 id="item-form-title" class="text-2xl font-bold text-amber-300">Novo Item (Pré-criado)</h2>
                    <button class="back-btn text-gray-400 hover:text-white transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24"
                            stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>
                <form id="itemForm" class="space-y-6">
                    <div>
                        <h3 class="text-xl font-bold text-amber-300 mb-2">Ícone do Item</h3>
                        <div class="mt-4 text-center">
                            <label for="itemImageUpload" class="block text-sm font-semibold mb-1 cursor-pointer">Faça
                                upload de uma imagem:</label>
                            <input type="file" id="itemImageUpload" accept="image/*" class="file-upload-input">
                            <img id="itemImagePreview"
                                class="mt-4 mx-auto w-32 h-32 object-cover rounded-full border-4 border-gray-600 hidden"
                                alt="Pré-visualização do Item">
                        </div>
                    </div>
                    <div><label for="itemName" class="block text-sm font-semibold mb-1">Nome</label><input type="text"
                            id="itemName" placeholder="Ex: Poção de Cura" required
                            class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600"></div>
                    <div class="grid grid-cols-2 gap-4">
                        <div><label for="itemType" class="block text-sm font-semibold mb-1">Tipo</label><input
                                type="text" id="itemType" placeholder="Ex: Leve"
                                class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600"></div>
                        <div><label for="itemDamage" class="block text-sm font-semibold mb-1">Dano</label><input
                                type="text" id="itemDamage" placeholder="Ex: 2d6"
                                class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600"></div>
                        <div><label for="itemCharge" class="block text-sm font-semibold mb-1">Carga</label><input
                                type="text" id="itemCharge" placeholder="Ex: 1" value="1"
                                class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600"></div>
                        <div><label for="itemPrerequisite"
                                class="block text-sm font-semibold mb-1">Pré-requisito</label><input type="text"
                                id="itemPrerequisite" placeholder="Ex: Saber magia"
                                class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600"></div>
                    </div>
                    <div>
                        <label for="itemUsable" class="block text-sm font-semibold mb-1">Usabilidade</label>
                        <select id="itemUsable"
                            class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600">
                            <option value="false">Não Usável</option>
                            <option value="true">Usável</option>
                        </select>
                    </div>
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label for="itemRestoreLife" class="block text-sm font-semibold mb-1">Restaurar Vida</label>
                            <input type="number" id="itemRestoreLife" placeholder="0"
                                class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600">
                        </div>
                        <div>
                            <label for="itemRestoreMana" class="block text-sm font-semibold mb-1">Restaurar Mana</label>
                            <input type="number" id="itemRestoreMana" placeholder="0"
                                class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600">
                        </div>
                    </div>
                    <div><label for="itemEffect" class="block text-sm font-semibold mb-1">Efeito</label><textarea
                            id="itemEffect" rows="4" placeholder="Ex: Explosão imediata gerando fogo..."
                            class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600"></textarea>
                    </div>
                    <button type="submit" id="itemSubmitButton"
                        class="w-full py-3 px-4 rounded-full text-lg font-bold text-white bg-gradient-to-r from-amber-500 to-orange-600 hover:from-amber-600 hover:to-orange-700 focus:outline-none transition duration-300 ease-in-out transform hover:scale-105 shadow-xl">
                        Salvar Item
                    </button>
                </form>
            </div>
        </div>

        <div id="item-display-section" class="hidden">
            <div id="item-thumbnail-list" class="flex flex-wrap gap-4 p-4 bg-gray-900/50 rounded-xl shadow-inner mb-4">
                <p class="text-gray-500">Nenhum item salvo ainda. Crie um para começar!</p>
            </div>
            <div id="item-card-display-area" class="w-full max-w-lg mx-auto mb-1 items-center justify-center"
                style="min-height: 720px;">
                <p class="text-gray-400">Selecione um item na lista acima para ver os detalhes.</p>
            </div>
        </div>

        <div id="link-section" class="hidden">
            <div class="bg-slate-800 text-white p-6 rounded-3xl shadow-2xl space-y-6">
                <div class="flex justify-between items-center">
                    <div class="text-center flex-grow">
                        <h2 id="link-section-title" class="text-2xl font-bold text-yellow-300">Gerenciar Personagem</h2>
                    </div>
                    <button class="back-btn text-gray-400 hover:text-white transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24"
                            stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>

                <div id="character-management-area" class="grid md:grid-cols-1 gap-6 justify-center">
                    <div id="inventory-management-area"
                        class="bg-gray-900/50 p-4 rounded-xl border border-gray-700 space-y-4">
                        <div class="flex justify-between items-center">
                            <div>
                                <h3 class="text-xl font-bold text-amber-300">Inventário</h3>
                                <p id="slots-info" class="text-sm text-gray-400">Slots disponíveis: 0</p>
                            </div>
                            <button id="add-item-btn"
                                class="py-2 px-4 rounded-full text-sm font-bold text-white bg-amber-600 hover:bg-amber-700 transition-colors flex items-center gap-2">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20"
                                    fill="currentColor">
                                    <path fill-rule="evenodd"
                                        d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z"
                                        clip-rule="evenodd" />
                                </svg>
                                Item
                            </button>
                        </div>
                        <div>
                            <h4 class="text-sm font-semibold text-gray-400 mb-2">Equipamento Especial</h4>
                            <div id="special-equipment-container" class="grid grid-cols-5 gap-2"></div>
                        </div>
                        <div>
                            <h4 class="text-sm font-semibold text-gray-400 mb-2">Itens com Carga</h4>
                            <div id="item-slots-container" class="grid grid-cols-5 gap-2"></div>
                        </div>
                        <div>
                            <h4 class="text-sm font-semibold text-gray-400 mb-2">Itens de Carga Zero</h4>
                            <div id="zero-charge-items-container" class="grid grid-cols-5 gap-2"></div>
                        </div>
                    </div>

                    <div id="spell-management-area" class="bg-gray-900/50 p-4 rounded-xl border border-gray-700">
                        <div class="flex justify-between items-center mb-4">
                            <div>
                                <h3 class="text-xl font-bold text-teal-300">Grimório</h3>
                                <p class="text-sm text-gray-400">Magias e habilidades conhecidas.</p>
                            </div>
                            <div class="flex items-center gap-2">
                                <select id="add-spell-type-select"
                                    class="px-2 py-2 bg-gray-700 text-white text-sm rounded-lg border border-gray-600">
                                    <option value="magia">Magia</option>
                                    <option value="habilidade">Habilidade</option>
                                </select>
                                <button id="add-spell-btn"
                                    class="p-2 rounded-full text-white bg-teal-600 hover:bg-teal-700 transition-colors">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20"
                                        fill="currentColor">
                                        <path fill-rule="evenodd"
                                            d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z"
                                            clip-rule="evenodd" />
                                    </svg>
                                </button>
                            </div>
                        </div>
                        <div id="linked-spells-container" class="grid grid-cols-5 gap-2">
                        </div>
                    </div>
                </div>

            </div>
        </div>

    </div>

    <div id="selection-modal" class="modal hidden">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h3 id="modal-title" class="text-xl font-bold">Selecione um Item</h3>
                <button id="modal-close-btn" class="text-gray-400 hover:text-white text-3xl font-bold">&times;</button>
            </div>
            <div id="modal-list" class="space-y-2 max-h-80 overflow-y-auto"></div>
        </div>
    </div>

    <div id="take-card-modal" class="modal hidden">
        <div class="modal-content flex flex-col items-center text-center">
            <h3 class="text-xl font-bold text-green-400 mb-4">Pegar este Card?</h3>
            <div id="take-card-preview" class="w-40 h-40 mb-4">
            </div>
            <p id="take-card-name" class="font-semibold mb-6"></p>
            <div class="flex gap-4 w-full">
                <button id="confirm-take-btn"
                    class="w-full py-2 px-4 rounded-full font-bold text-white bg-green-600 hover:bg-green-700 transition-colors">Sim,
                    Pegar!</button>
                <button id="cancel-take-btn"
                    class="w-full py-2 px-4 rounded-full font-bold text-white bg-gray-600 hover:bg-gray-700 transition-colors">Cancelar</button>
            </div>
        </div>
    </div>

    <div id="share-item-modal" class="modal hidden">
        <div class="modal-content">
            <h3 class="text-xl font-bold text-amber-300 mb-4">Publicar Item no Mercado</h3>
            <form id="share-item-form" class="space-y-4">
                <div>
                    <label for="share-item-price" class="block text-sm font-semibold mb-1">Preço por Unidade (0 para
                        gratuito)</label>
                    <input type="number" id="share-item-price" min="0" value="0"
                        class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600">
                </div>
                <div>
                    <label for="share-item-quantity" class="block text-sm font-semibold mb-1">Quantidade para
                        Vender</label>
                    <input type="number" id="share-item-quantity" min="1" value="1"
                        class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600">
                </div>
                <div class="flex items-center">
                    <input type="checkbox" id="share-item-remove-after"
                        class="form-checkbox h-4 w-4 text-indigo-500 rounded border-gray-600">
                    <label for="share-item-remove-after" class="ml-2 text-sm text-gray-300">Remover da minha coleção
                        após ser pego?</label>
                </div>
                <div class="flex gap-4 w-full pt-4">
                    <button type="submit"
                        class="w-full py-2 px-4 rounded-full font-bold text-white bg-green-600 hover:bg-green-700 transition-colors">Publicar</button>
                    <button type="button" id="cancel-share-item-btn"
                        class="w-full py-2 px-4 rounded-full font-bold text-white bg-gray-600 hover:bg-gray-700 transition-colors">Cancelar</button>
                </div>
            </form>
        </div>
    </div>

    <div id="buy-item-modal" class="modal hidden">
        <div class="modal-content flex flex-col items-center text-center">
            <h3 class="text-xl font-bold text-green-400 mb-4">Comprar Item</h3>
            <div id="buy-item-preview" class="w-32 h-32 mb-4"></div>
            <p id="buy-item-name" class="font-semibold"></p>
            <p id="buy-item-price" class="text-sm text-amber-400 mb-4"></p>

            <div class="w-full space-y-4">
                <div>
                    <label for="buy-quantity" class="block text-sm font-semibold mb-1">Quantidade (Disponível: <span
                            id="buy-item-available"></span>)</label>
                    <input type="number" id="buy-quantity" min="1" value="1"
                        class="w-full text-center px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600">
                </div>
                <p class="font-bold">Total: <span id="buy-total-cost" class="text-amber-300">0</span> 💰</p>
                <div>
                    <label for="buy-character-select" class="block text-sm font-semibold mb-1">Pagar com:</label>
                    <select id="buy-character-select"
                        class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600"></select>
                </div>
            </div>

            <div class="flex gap-4 w-full mt-6">
                <button id="confirm-buy-btn"
                    class="w-full py-2 px-4 rounded-full font-bold text-white bg-green-600 hover:bg-green-700 transition-colors">Comprar</button>
                <button id="cancel-buy-btn"
                    class="w-full py-2 px-4 rounded-full font-bold text-white bg-gray-600 hover:bg-gray-700 transition-colors">Cancelar</button>
            </div>
        </div>
    </div>


    <div id="status-modal" class="modal hidden">
        <div class="modal-content" style="width: 50%;">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold text-indigo-300">Alterar Status</h3>
                <button id="status-modal-close-btn"
                    class="text-gray-400 hover:text-white text-3xl font-bold">&times;</button>
            </div>
            <form id="status-form" class="space-y-4">
                <div id="vida-input-container">
                    <label for="modal-vida-atual" class="block text-sm font-semibold mb-1">Vida Atual</label>
                    <input type="number" id="modal-vida-atual"
                        class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600">
                </div>
                <div id="mana-input-container">
                    <label for="modal-mana-atual" class="block text-sm font-semibold mb-1">Mana Atual</label>
                    <input type="number" id="modal-mana-atual"
                        class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600">
                </div>
                <div id="dinheiro-input-container">
                    <label for="modal-dinheiro" class="block text-sm font-semibold mb-1">Dinheiro</label>
                    <input type="number" id="modal-dinheiro"
                        class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg border border-gray-600">
                </div>
                <button type="submit"
                    class="w-full py-2 px-4 rounded-full font-bold text-white bg-indigo-600 hover:bg-indigo-700 transition-colors">
                    Salvar Alterações
                </button>
            </form>
        </div>
    </div>

    <div id="confirm-modal" class="modal hidden">
        <div class="modal-content flex flex-col items-center text-center">
            <h3 id="confirm-modal-title" class="text-xl font-bold text-yellow-400 mb-4">Você tem certeza?</h3>
            <p id="confirm-modal-text" class="mb-6"></p>
            <div class="flex items-center mb-4">
                <input type="checkbox" id="confirm-modal-checkbox"
                    class="form-checkbox h-4 w-4 text-indigo-500 rounded border-gray-600">
                <label id="confirm-modal-checkbox-label" for="confirm-modal-checkbox"
                    class="ml-2 text-sm text-gray-300">Opção</label>
            </div>
            <div class="flex gap-4 w-full">
                <button id="confirm-modal-yes-btn"
                    class="w-full py-2 px-4 rounded-full font-bold text-white bg-green-600 hover:bg-green-700 transition-colors">Sim</button>
                <button id="confirm-modal-no-btn"
                    class="w-full py-2 px-4 rounded-full font-bold text-white bg-gray-600 hover:bg-gray-700 transition-colors">Não</button>
            </div>
        </div>
    </div>

    <!-- Container para os menus de navegação -->
    <div class="fixed bottom-4 left-1/2 -translate-x-1/2 flex items-end gap-2 z-50">
        <nav id="nav" class="bg-gray-800/80 backdrop-blur-sm rounded-full p-2 flex items-center gap-2 shadow-lg">
            <button id="showDisplayBtn"
                class="nav-button px-4 py-2 text-sm md:px-6 md:py-3 md:text-lg font-semibold rounded-full focus:outline-none flex items-center gap-2"
                title="Personagens">
                <i class="fas fa-users"></i>
                <span class="hidden md:inline">Personagens</span>
            </button>
            <button id="showSpellDisplayBtn"
                class="nav-button px-4 py-2 text-sm md:px-6 md:py-3 md:text-lg font-semibold rounded-full focus:outline-none flex items-center gap-2"
                title="Grimório">
                <i class="fas fa-book"></i>
                <span class="hidden md:inline">Biblioteca</span>
            </button>
            <button id="showItemDisplayBtn"
                class="nav-button px-4 py-2 text-sm md:px-6 md:py-3 md:text-lg font-semibold rounded-full focus:outline-none flex items-center gap-2"
                title="Inventário">
                <i class="fas fa-box"></i>
                <span class="hidden md:inline">Inventário</span>
            </button>
            <button id="showShareBtn"
                class="nav-button px-4 py-2 text-sm md:px-6 md:py-3 md:text-lg font-semibold rounded-full focus:outline-none flex items-center gap-2"
                title="Compartilhar">
                <i class="fas fa-share-alt"></i>
                <span class="hidden md:inline">Compartilhar</span>
            </button>
            <button id="mute-button" title="Ativar/Desativar som"
                class="px-4 py-2 text-sm md:px-6 md:py-3 md:text-lg font-semibold rounded-full focus:outline-none flex items-center gap-2">
                <i id="volume-icon" class="fas fa-volume-mute"></i>
            </button>
        </nav>
        <nav id="db-nav" class="bg-gray-800/80 backdrop-blur-sm rounded-full p-2 flex items-center gap-2 shadow-lg">
            <button id="importDbBtn"
                class="nav-button px-4 py-2 text-sm md:px-6 md:py-3 md:text-lg font-semibold rounded-full focus:outline-none flex items-center gap-2"
                title="Importar Backup Local">
                <i class="fas fa-upload"></i>
            </button>
            <button id="downloadDbBtn"
                class="nav-button px-4 py-2 text-sm md:px-6 md:py-3 md:text-lg font-semibold rounded-full focus:outline-none flex items-center gap-2"
                title="Baixar Backup Local">
                <i class="fas fa-database"></i>
            </button>
        </nav>
    </div>

    <script type="module">
        import {
            initializeApp
        } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        // MODIFICADO: Adicionado 'update'
        import { getDatabase, ref, onValue, set, remove, runTransaction, update } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js"; const firebaseConfig = {
            apiKey: "AIzaSyCSFhUNp0weU09S13kZmUd0-J50-eHW1YU",
            authDomain: "farland-cards.firebaseapp.com",
            projectId: "farland-cards",
            storageBucket: "farland-cards.appspot.com",
            messagingSenderId: "347739610452",
            appId: "1:347739610452:web:d3b172dea431944365fcc1",
            measurementId: "G-8T74ETC4GV",
            databaseURL: "https://farland-cards-default-rtdb.firebaseio.com"
        };
        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);
        window.firebaseDB = { database, ref, onValue, set, remove, runTransaction, update };
    </script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {

            const {
                database,
                ref,
                onValue,
                set,
                remove,
                runTransaction
            } = window.firebaseDB;
            const backgroundMusic = document.getElementById('background-music');
            const muteButton = document.getElementById('mute-button');
            const volumeIcon = document.getElementById('volume-icon');
            backgroundMusic.volume = 0.3;
            backgroundMusic.play()
                .then(() => {
                    backgroundMusic.muted = false;
                    volumeIcon.classList.remove('fa-volume-mute');
                    volumeIcon.classList.add('fa-volume-up');
                    muteButton.classList.add('playing');
                })
                .catch(error => {
                    console.log("Reprodução automática bloqueada. Clique no botão para iniciar.");
                });
            muteButton.addEventListener('click', () => {
                if (backgroundMusic.paused) {
                    backgroundMusic.play();
                }
                if (backgroundMusic.muted) {
                    backgroundMusic.muted = false;
                    volumeIcon.classList.remove('fa-volume-mute');
                    volumeIcon.classList.add('fa-volume-up');
                    muteButton.classList.add('playing');
                } else {
                    backgroundMusic.muted = true;
                    volumeIcon.classList.remove('fa-volume-up');
                    volumeIcon.classList.add('fa-volume-mute');
                    muteButton.classList.remove('playing');
                }
            });
            backgroundMusic.addEventListener('play', () => {
                if (!backgroundMusic.muted) {
                    volumeIcon.classList.remove('fa-volume-mute');
                    volumeIcon.classList.add('fa-volume-up');
                    muteButton.classList.add('playing');
                }
            });
            const root = document.documentElement;
            let audioContext;

            function initAudioContext() {
                if (!audioContext) {
                    try {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    } catch (e) {
                        console.error("Web Audio API is not supported in this browser");
                    }
                }
            }
            document.body.addEventListener('click', initAudioContext, {
                once: true
            });
            document.body.addEventListener('touchend', initAudioContext, {
                once: true
            });
            async function playMp3Sound(url) {
                if (!audioContext) {
                    console.log("Audio Context not ready.");
                    return;
                }
                try {
                    const response = await fetch(url);
                    const arrayBuffer = await response.arrayBuffer();
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    const source = audioContext.createBufferSource();
                    source.buffer = audioBuffer;
                    source.connect(audioContext.destination);
                    source.start(0);
                } catch (error) {
                    console.error("Error playing MP3:", error);
                }
            }

            function triggerCardPunch(card3d) {
                playMp3Sound('sopro.mp3');
                createDamageOverlay(card3d);
                card3d.classList.add('zoom-box', 'glow-red');
                setTimeout(() => {
                    playMp3Sound('dano.mp3');
                }, 800);
                setTimeout(() => {
                    const overlay = card3d.querySelector('.damage-overlay');
                    if (overlay) {
                        overlay.remove();
                    }
                }, 1200);
            }

            function triggerCardLifeIn(card3d, vidaIcon) {
                playMp3Sound('magia.mp3');
                createHealOverlay(card3d);
                card3d.classList.add('heal-container', 'glow-green');
                setTimeout(() => {
                    const overlay = card3d.querySelector('.heal-overlay');
                    if (overlay) {
                        overlay.remove();
                        createManaMist(vidaIcon, 'in', '#ff1a1a');
                        resetcard3d(card3d);
                        card3d.classList.add('spill-container', 'glowing-card', 'glow-red');
                        triggerAnimation(card3d, 'animate');
                    }
                }, 1200);
            }
            /**
             * Cria um efeito de partículas de mana (névoa/estrelas) a partir de um elemento.
             * @param {HTMLElement} containerElement - O elemento de onde as partículas devem emergir.
             */
            function createManaMist(containerElement, direction = 'out', color = '#a78bfa') {
                const particleCount = 20;
                for (let i = 0; i < particleCount; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'mana-particle';
                    containerElement.appendChild(particle);
                    const size = Math.random() * 8 + 2;
                    const x = (Math.random() - 0.5) * 150;
                    const y = (Math.random() - 0.5) * 150;
                    const duration = Math.random() * 1.5 + 0.5;
                    particle.style.width = `${size}px`;
                    particle.style.height = `${size}px`;
                    particle.style.setProperty('--particle-color', color);
                    particle.style.setProperty('--x', `${x}px`);
                    particle.style.setProperty('--y', `${y}px`);
                    const animationName = direction === 'in' ?
                        'mana-mist-in' : 'mana-mist-out';
                    particle.style.animation = `${animationName} ${duration}s ease-out forwards`;
                    setTimeout(() => {
                        particle.remove();
                    }, duration * 1000);
                }
            }

            function updateHeartVisuals(currentLife, maxLife) {
                let current = parseInt(currentLife) ||
                    0;
                let max = parseInt(maxLife) || 1;
                const lifePercentage = max > 0 ?
                    (Math.max(0, current) / max) * 100 : 0;
                root.style.setProperty('--life-percent', lifePercentage.toFixed(2));
            }

            function updatePotionVisuals(currentMana, maxMana) {
                let current = parseInt(currentMana) ||
                    0;
                let max = parseInt(maxMana) || 1;
                const manaPercentage = max > 0 ?
                    (Math.max(0, current) / max) * 100 : 0;
                root.style.setProperty('--mana-percent', manaPercentage.toFixed(2));
            }
            const periciasData = {
                "AGILIDADE": {
                    "Acrobacia": "Capacidade de realizar movimentos ágeis e controlados...",
                    "Iniciativa": "Velocidade de reação quando o combate começa...",
                    "Montaria": "Controle de veículos e montarias complexas...",
                    "Furtividade": "A arte de mover-se sem ser notado...",
                    "Pontaria": "Precisão com armas de longo alcance...",
                    "Ladinagem": "Manipulação veloz e precisa com as mãos...",
                    "Reflexos": "Rapidez em reagir a estímulos..."
                },
                "CARISMA": {
                    "Adestramento": "Treinamento e comando de animais...",
                    "Enganação": "A arte de manipular a verdade...",
                    "Intimidação": "Uso da força de personalidade para impor medo...",
                    "Persuasão": "A habilidade de influenciar e inspirar..."
                },
                "INTELIGÊNCIA": {
                    "Arcanismo": "Conhecimento das artes místicas...",
                    "História": "Memória de tempos antigos...",
                    "Investigação": "Capacidade de analisar cenários e reunir pistas...",
                    "Ofício": "Criação, manutenção e reparo de objetos...",
                    "Religião": "Conhecimento sobre divindades e rituais...",
                    "Tecnologia": "Compreensão de mecanismos e engenhocas..."
                },
                "FORÇA": {
                    "Atletismo": "Medida da força bruta aplicada com técnica...",
                    "Luta": "Combate corpo a corpo com armas simples ou improvisadas..."
                },
                "SABEDORIA": {
                    "Intuição": "Habilidade de ler emoções e detectar mentiras...",
                    "Percepção": "Capacidade de notar detalhes ao redor...",
                    "Medicina": "Conhecimento de curas e tratamento de feridas...",
                    "Natureza": "Sabedoria sobre o mundo natural...",
                    "Sobrevivência": "A perícia de se adaptar ao mundo selvagem...",
                    "Vontade": "Força interior e estabilidade emocional..."
                },
                "VIGOR": {
                    "Fortitude": "Resistência física e imunológica do personagem..."
                }
            };

            function initiateFullImport() {
                // Reutiliza o input de arquivo JSON já existente
                currentStoreForImport = 'full_database'; // Um identificador especial para o import completo
                jsonImportInput.value = null; // Reseta para permitir selecionar o mesmo arquivo novamente
                jsonImportInput.click();
            }

            // Adicione o novo event listener para o botão de importação
            document.getElementById('importDbBtn').addEventListener('click', initiateFullImport);

            const cardForm = document.getElementById('cardForm');
            const spellForm = document.getElementById('spellForm');
            const itemForm = document.getElementById('itemForm');
            const cardDisplayArea = document.getElementById('card-display-area');
            const spellCardDisplayArea = document.getElementById('spell-card-display-area');
            const itemCardDisplayArea = document.getElementById('item-card-display-area');
            const submitButton = document.getElementById('submitButton');
            const spellSubmitButton = document.getElementById('spellSubmitButton');
            const itemSubmitButton = document.getElementById('itemSubmitButton');
            const thumbnailList = document.getElementById('thumbnail-list');
            const spellThumbnailList = document.getElementById('spell-thumbnail-list');
            const habThumbnailList = document.getElementById('spell-thumbnail-list-hab');
            const itemThumbnailList = document.getElementById('item-thumbnail-list');
            const formTitle = document.getElementById('form-title');
            const spellFormTitle = document.getElementById('spell-form-title');
            const itemFormTitle = document.getElementById('item-form-title');
            const cardTitleInput = document.getElementById('cardTitle');
            const cardSubTitleInput = document.getElementById('cardSubTitle');
            const cardLevelInput = document.getElementById('cardLevel');
            const dinheiroInput = document.getElementById('dinheiro');
            const characterImageUpload = document.getElementById('characterImageUpload');
            const backgroundImageUpload = document.getElementById('backgroundImageUpload');
            const characterImagePreview = document.getElementById('characterImagePreview');
            const backgroundImagePreview = document.getElementById('backgroundImagePreview');
            const vidaInput = document.getElementById('vida');
            const manaInput = document.getElementById('mana');
            const vidaAtualInput = document.getElementById('vidaAtual');
            const manaAtualInput = document.getElementById('manaAtual');
            const armaduraInput = document.getElementById('armadura');
            const esquivaInput = document.getElementById('esquiva');
            const bloqueioInput = document.getElementById('bloqueio');
            const deslocamentoInput = document.getElementById('deslocamento');
            const agilidadeInput = document.getElementById('agilidade');
            const carismaInput = document.getElementById('carisma');
            const forcaInput = document.getElementById('forca');
            const inteligenciaInput = document.getElementById('inteligencia');
            const sabedoriaInput = document.getElementById('sabedoria');
            const vigorInput = document.getElementById('vigor');
            const historiaInput = document.getElementById('historia');
            const personalidadeInput = document.getElementById('personalidade');
            const motivacaoInput = document.getElementById('motivacao');
            const periciasCheckboxesContainer = document.getElementById('pericias-checkboxes-container');
            const periciaDescriptionDisplay = document.getElementById('pericia-description-display');
            const periciaDescriptionTitle = document.getElementById('periciaDescriptionTitle');
            const periciaDescriptionText = document.getElementById('periciaDescriptionText');
            const spellImageUpload = document.getElementById('spellImageUpload');
            const spellImagePreview = document.getElementById('spellImagePreview');
            const itemImageUpload = document.getElementById('itemImageUpload');
            const itemImagePreview = document.getElementById('itemImagePreview');
            const jsonImportInput = document.getElementById('jsonImportInput');
            const splashScreen = document.getElementById('splashScreen');
            const loaderClipRect = document.getElementById('loaderClipRect');
            const progressText = document.getElementById('progressText');
            const mainContent = document.getElementById('mainContent');
            const nav = document.getElementById('nav');
            const dbnav = document.getElementById('db-nav');
            const showDisplayBtn = document.getElementById('showDisplayBtn');
            const showSpellDisplayBtn = document.getElementById('showSpellDisplayBtn');
            const showItemDisplayBtn = document.getElementById('showItemDisplayBtn');
            const saveDbBtn = document.getElementById('saveDbBtn');
            const vidaInputContainer = document.getElementById('vida-input-container');
            const manaInputContainer = document.getElementById('mana-input-container');
            const dinheiroInputContainer = document.getElementById('dinheiro-input-container');
            const creationSection = document.getElementById('creation-section');
            const displaySection = document.getElementById('display-section');
            const spellDisplaySection = document.getElementById('spell-display-section');
            const itemDisplaySection = document.getElementById('item-display-section');
            const spellCreationSection = document.getElementById('spell-creation-section');
            const itemCreationSection = document.getElementById('item-creation-section');
            const linkSection = document.getElementById('link-section');
            const linkSectionTitle = document.getElementById('link-section-title');
            const characterManagementArea = document.getElementById('character-management-area');
            const inventoryManagementArea = document.getElementById('inventory-management-area');
            const spellManagementArea = document.getElementById('spell-management-area');
            const slotsInfo = document.getElementById('slots-info');
            const itemSlotsContainer = document.getElementById('item-slots-container');
            const specialEquipmentContainer = document.getElementById('special-equipment-container');
            const zeroChargeItemsContainer = document.getElementById('zero-charge-items-container');
            const linkedSpellsContainer = document.getElementById('linked-spells-container');
            const addSpellBtn = document.getElementById('add-spell-btn');
            const addSpellTypeSelect = document.getElementById('add-spell-type-select');
            const addItemBtn = document.getElementById('add-item-btn');
            const selectionModal = document.getElementById('selection-modal');
            const modalTitle = document.getElementById('modal-title');
            const modalCloseBtn = document.getElementById('modal-close-btn');
            const modalList = document.getElementById('modal-list');
            const statusModal = document.getElementById('status-modal');
            const statusModalCloseBtn = document.getElementById('status-modal-close-btn');
            const statusForm = document.getElementById('status-form');
            const modalVidaAtualInput = document.getElementById('modal-vida-atual');
            const modalManaAtualInput = document.getElementById('modal-mana-atual');
            const modalDinheiroInput = document.getElementById('modal-dinheiro');
            const loadingMessages = ['Invocando o Grimório...', 'Forjando Cartões...', 'Organizando o Inventário...', 'Sincronizando com os Reinos...'];
            let userId = getUserId();
            const showShareBtn = document.getElementById('showShareBtn');
            const shareSection = document.getElementById('share-section');

            // --- INÍCIO: Lógica para o formulário de itens ---

            const itemUsableSelect = document.getElementById('itemUsable');
            const itemRestoreLifeInput = document.getElementById('itemRestoreLife');
            const itemRestoreManaInput = document.getElementById('itemRestoreMana');
            const restoreLifeContainer = itemRestoreLifeInput.parentElement;
            const restoreManaContainer = itemRestoreManaInput.parentElement;

            // Função para mostrar/ocultar campos de Vida e Mana
            function updateItemFormVisibility() {
                const isUsable = itemUsableSelect.value === 'true';
                restoreLifeContainer.classList.toggle('hidden', !isUsable);
                restoreManaContainer.classList.toggle('hidden', !isUsable);

                // Se não for usável, limpa e reseta os campos
                if (!isUsable) {
                    itemRestoreLifeInput.value = 0;
                    itemRestoreManaInput.value = 0;
                    itemRestoreLifeInput.disabled = false;
                    itemRestoreManaInput.disabled = false;
                }
            }

            // Função para desabilitar um campo quando o outro é preenchido
            function handleRestoreInputs() {
                const lifeValue = parseInt(itemRestoreLifeInput.value) || 0;
                const manaValue = parseInt(itemRestoreManaInput.value) || 0;

                // Se houver valor em Vida, desabilita Mana. Senão, habilita.
                itemRestoreManaInput.disabled = lifeValue > 0;

                // Se houver valor em Mana, desabilita Vida. Senão, habilita.
                itemRestoreLifeInput.disabled = manaValue > 0;
            }

            // Adiciona os "ouvintes" de eventos
            itemUsableSelect.addEventListener('change', updateItemFormVisibility);
            itemRestoreLifeInput.addEventListener('input', handleRestoreInputs);
            itemRestoreManaInput.addEventListener('input', handleRestoreInputs);

            // --- FIM: Lógica para o formulário de itens ---

            const spellTypeSelect = document.getElementById('spellType');
            const fieldsToToggle = [
                document.getElementById('spellExecution').parentElement,
                document.getElementById('spellRange').parentElement,
                document.getElementById('spellTarget').parentElement,
                document.getElementById('spellDuration').parentElement,
                document.getElementById('spellResistencia').parentElement,
                document.getElementById('spellEnhance').parentElement,
                document.getElementById('spellTrue').parentElement
            ];

            function updateSpellFormVisibility() {
                const isHabilidade = spellTypeSelect.value === 'habilidade';
                fieldsToToggle.forEach(field => {
                    if (field) {
                        // Usando 'hidden' do Tailwind CSS para ocultar
                        field.classList.toggle('hidden', isHabilidade);
                    }
                });
            }

            spellTypeSelect.addEventListener('change', updateSpellFormVisibility);
            // NOVOS ELEMENTOS DO DOM
            const marketCharactersList = document.getElementById('market-characters-list');
            const marketSpellsList = document.getElementById('market-spells-list');
            const marketPaidItemsList = document.getElementById('market-paid-items-list');
            const marketFreeItemsList = document.getElementById('market-free-items-list');
            const shareItemModal = document.getElementById('share-item-modal');
            const shareItemForm = document.getElementById('share-item-form');
            const cancelShareItemBtn = document.getElementById('cancel-share-item-btn');
            const confirmModal = document.getElementById('confirm-modal');
            const buyItemModal = document.getElementById('buy-item-modal');
            const buyQuantityInput = document.getElementById('buy-quantity');
            const buyTotalCost = document.getElementById('buy-total-cost');
            const buyCharacterSelect = document.getElementById('buy-character-select');

            const takeCardModal = document.getElementById('take-card-modal');
            const confirmTakeBtn = document.getElementById('confirm-take-btn');
            const cancelTakeBtn = document.getElementById('cancel-take-btn');
            const takeCardPreview = document.getElementById('take-card-preview');
            const takeCardName = document.getElementById('take-card-name');

            // --- ADICIONE ESTA LINHA ---
            let charactersOnTableIds = new Set();
            // --- FIM DA LINHA ADICIONADA ---

            let currentCardToShare = null;


            function updateActiveNav(activeButton) {
                [showDisplayBtn, showSpellDisplayBtn, showItemDisplayBtn, showShareBtn].forEach(button => {
                    button.classList.remove('active');
                });
                if (activeButton) {
                    activeButton.classList.add('active');
                }
            }

            function hideAllSections() {
                creationSection.classList.add('hidden');
                displaySection.classList.add('hidden');
                spellCreationSection.classList.add('hidden');
                spellDisplaySection.classList.add('hidden');
                itemCreationSection.classList.add('hidden');
                itemDisplaySection.classList.add('hidden');
                linkSection.classList.add('hidden');
                shareSection.classList.add('hidden');
            }

            function showDisplayView() {
                hideAllSections();
                displaySection.classList.remove('hidden');
                updateActiveNav(showDisplayBtn);
            }

            function showCreationView(isEditing = false) {
                hideAllSections();
                creationSection.classList.remove('hidden');
                nav.classList.remove('hidden');
                dbnav.classList.remove('hidden');
                if (!isEditing) {
                    formTitle.textContent = "Criar Novo Cartão de Personagem";
                    submitButton.textContent = 'Criar Cartão';
                    submitButton.classList.add('btn-gradient-pulse');
                    cardForm.reset();
                    populatePericiasCheckboxes();
                    showImagePreview(characterImagePreview, null, true);
                    showImagePreview(backgroundImagePreview, null, false);
                    currentEditingCardId = null;
                }
            }

            function showSpellCreationView(isEditing = false) {
                hideAllSections();
                spellCreationSection.classList.remove('hidden');
                nav.classList.remove('hidden');
                dbnav.classList.remove('hidden');
                if (!isEditing) {
                    spellFormTitle.textContent = "Nova Magia/Habilidade";
                    spellSubmitButton.textContent = 'Salvar';
                    spellForm.reset();
                    showImagePreview(spellImagePreview, null, true);
                    currentEditingSpellId = null;
                }
            }

            function showSpellDisplayView() {
                hideAllSections();
                spellDisplaySection.classList.remove('hidden');
                updateActiveNav(showSpellDisplayBtn);
            }

            function showItemCreationView(isEditing = false) {
                hideAllSections();
                itemCreationSection.classList.remove('hidden');
                nav.classList.remove('hidden');
                dbnav.classList.remove('hidden');
                if (!isEditing) {
                    itemFormTitle.textContent = "Novo Item (Pré-criado)";
                    itemSubmitButton.textContent = 'Salvar Item';
                    itemForm.reset();
                    document.getElementById('itemCharge')
                        .value = 1;
                    showImagePreview(itemImagePreview, null, true);
                    currentEditingItemId = null;
                }
                // ADICIONE AS DUAS LINHAS ABAIXO
                updateItemFormVisibility();
                handleRestoreInputs();
            }

            function showItemDisplayView() {
                hideAllSections();
                itemDisplaySection.classList.remove('hidden');
                updateActiveNav(showItemDisplayBtn);
            }
            let marketListenerAttached = false;
            let isSharingACard = false;

            function showShareView() {
                hideAllSections();
                shareSection.classList.remove('hidden');
                updateActiveNav(showShareBtn);
                renderMyCardsForSharing();
                if (!marketListenerAttached) {
                    listenToMarket();
                    marketListenerAttached = true;
                }
            }

            function getUserId() {
                let id = localStorage.getItem('rpg-card-user-id');
                if (!id) {
                    id = `user-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                    localStorage.setItem('rpg-card-user-id', id);
                }
                return id;
            }
            /**
             * Comprime e redimensiona uma imagem usando a API Canvas.
             * @param {File} file O arquivo de imagem original.
             * @param {object} options Opções de compressão.
             * @param {number} options.quality A qualidade do JPEG (0 a 1).
             * @param {number} options.maxWidth A largura máxima da imagem.
             * @returns {Promise<Blob>} Uma Promise que resolve com a imagem comprimida como um Blob.
             */
            function compressImage(file, options = {
                quality: 0.3,
                maxWidth: 400
            }) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        img.src = e.target.result;
                    };
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        let width = img.width;
                        let height = img.height;
                        if (width > options.maxWidth) {
                            height = (options.maxWidth / width) * height;
                            width = options.maxWidth;
                        }
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);
                        canvas.toBlob(
                            (blob) => {
                                if (blob) {
                                    resolve(blob);
                                } else {
                                    reject(new Error('Falha ao criar o blob da imagem.'));
                                }
                            },
                            'image/jpeg',
                            options.quality
                        );
                    };
                    img.onerror = (error) => reject(error);
                    reader.readAsDataURL(file);
                });
            }

            // FUNÇÃO shareCard ATUALIZADA
            async function shareCard(cardId, type, element, options = {}) {
                if (isSharingACard) {
                    showCustomAlert("Aguarde a operação anterior ser concluída.");
                    return;
                }
                if (element.classList.contains('is-shared')) return;
                isSharingACard = true;
                element.classList.add('is-sharing');

                let storeName;
                switch (type) {
                    case 'character': storeName = CARD_STORE_NAME;
                        break;
                    case 'spell': storeName = SPELL_STORE_NAME;
                        break;
                    case 'item': storeName = ITEM_STORE_NAME;
                        break;
                    default: isSharingACard = false;
                        element.classList.remove('is-sharing');
                        return;
                }

                try {
                    const cardData = await getData(storeName, cardId);
                    if (!cardData) {
                        throw new Error("Card data not found");
                    }

                    let cardDataForFirebase = {
                        ...cardData
                    };
                    if (cardDataForFirebase.image) cardDataForFirebase.imageBase64 = arrayBufferToBase64(cardDataForFirebase.image);
                    if (cardDataForFirebase.backgroundImage) cardDataForFirebase.backgroundImageBase64 = arrayBufferToBase64(cardDataForFirebase.backgroundImage);
                    delete cardDataForFirebase.image;
                    delete cardDataForFirebase.backgroundImage;

                    const marketKey = `${userId}-${cardId}`;
                    const cardRef = ref(database, 'market/' + marketKey);

                    const dataToShare = {
                        ...cardDataForFirebase,
                        ownerId: userId,
                        cardType: type,
                        price: options.price || 0,
                        quantity: options.quantity || 1,
                        removeFromOwnerOnTake: options.removeFromOwnerOnTake || false
                    };

                    await set(cardRef, dataToShare);

                    // --- INÍCIO DA CORREÇÃO ---
                    // Se a opção de remover ao pegar foi marcada, salvamos a informação localmente.
                    if (options.removeFromOwnerOnTake) {
                        const previouslyShared = JSON.parse(localStorage.getItem('mySharedCards') || '{}');
                        // Usamos o cardData original (com ArrayBuffer, não Base64) que a função handlePostTakeActions espera.
                        previouslyShared[cardId] = {
                            removeFromOwnerOnTake: true,
                            cardData: {
                                ...cardData,
                                cardType: type
                            } // Adiciona o tipo para uso futuro
                        };
                        localStorage.setItem('mySharedCards', JSON.stringify(previouslyShared));
                    }
                    // --- FIM DA CORREÇÃO ---

                    element.classList.remove('is-sharing');
                    element.classList.add('is-shared');
                    element.title = `Clique para remover "${dataToShare.title || dataToShare.name}" do mercado`;
                    isSharingACard = false;

                } catch (error) {
                    console.error("Erro ao compartilhar:", error);
                    alert("Falha ao compartilhar o card.");
                    element.classList.remove('is-sharing');
                    isSharingACard = false;
                }
            }

            async function removeFromMarket(cardId, element) {
                if (isSharingACard) {
                    showCustomAlert("Aguarde a operação anterior ser concluída.");
                    return;
                }
                if (!element.classList.contains('is-shared')) return;
                isSharingACard = true;
                element.classList.add('is-sharing');

                const marketKey = `${userId}-${cardId}`;
                const cardRef = ref(database, 'market/' + marketKey);
                try {
                    await remove(cardRef);

                    // --- INÍCIO DA CORREÇÃO ---
                    // Limpa o registro local para este card, já que não está mais no mercado.
                    const previouslyShared = JSON.parse(localStorage.getItem('mySharedCards') || '{}');
                    if (previouslyShared[cardId]) {
                        delete previouslyShared[cardId];
                        localStorage.setItem('mySharedCards', JSON.stringify(previouslyShared));
                    }
                    // --- FIM DA CORREÇÃO ---

                    element.classList.remove('is-sharing');
                    element.classList.remove('is-shared');
                    element.title = `Clique para compartilhar "${element.querySelector('p').textContent}"`;
                    isSharingACard = false;
                } catch (error) {
                    console.error("Erro ao remover card do mercado:", error);
                    alert("Falha ao remover o card do mercado.");
                    element.classList.remove('is-sharing');
                    isSharingACard = false;
                }
            }
            // FUNÇÃO ATUALIZADA PARA LIDAR COM A REMOÇÃO LOCAL APÓS A COMPRA
            async function handlePostTakeActions(cardData) {
                // A verificação `removeFromOwnerOnTake` já é feita na função `listenToMarket` antes de chamar esta.
                // Portanto, a verificação interna foi removida para corrigir o bug.

                const type = cardData.cardType;
                let storeName;
                switch (type) {
                    case 'character': storeName = CARD_STORE_NAME;
                        break;
                    case 'spell': storeName = SPELL_STORE_NAME;
                        break;
                    case 'item': storeName = ITEM_STORE_NAME;
                        break;
                    default: return; // Sai se o tipo for desconhecido
                }

                // 1. Remover o card principal do banco de dados local
                await removeData(storeName, cardData.id);

                // 2. Se o card removido for um item ou magia, também o remove de qualquer personagem que o possua.
                if (type === 'item' || type === 'spell') {
                    const allCharacters = await getData(CARD_STORE_NAME);
                    for (const char of allCharacters) {
                        let updated = false;
                        if (type === 'item' && char.items && char.items.includes(cardData.id)) {
                            char.items = char.items.filter(id => id !== cardData.id);
                            updated = true;
                        }
                        if (type === 'spell' && char.spells && char.spells.includes(cardData.id)) {
                            char.spells = char.spells.filter(id => id !== cardData.id);
                            updated = true;
                        }
                        if (updated) {
                            await saveData(CARD_STORE_NAME, char);
                        }
                    }
                }

                showCustomAlert(`'${cardData.title || cardData.name}' foi pego e removido da sua coleção.`, 'success');

                // 3. (NOVO) Atualiza a lista de cards na tela de compartilhamento para refletir a remoção.
                await renderMyCardsForSharing();
            }
            async function takeCard(marketCardKey, cardData) {
                const cardToSave = {
                    ...cardData
                };
                delete cardToSave.ownerId;
                const type = cardToSave.cardType;
                delete cardToSave.cardType;

                if (cardToSave.imageBase64) cardToSave.image = base64ToArrayBuffer(cardToSave.imageBase64);
                if (cardToSave.backgroundImageBase64) cardToSave.backgroundImage = base64ToArrayBuffer(cardToSave.backgroundImageBase64);

                let storeName;
                switch (type) {
                    case 'character': storeName = CARD_STORE_NAME;
                        break;
                    case 'spell': storeName = SPELL_STORE_NAME;
                        break;
                    case 'item': storeName = ITEM_STORE_NAME;
                        break;
                    default:
                        return;
                }

                // A lógica para salvar o item na coleção do comprador permanece a mesma.
                if (type === 'item') {
                    const quantity = cardData.quantityToBuy || 1;
                    for (let i = 0; i < quantity; i++) {
                        const newItem = {
                            ...cardToSave,
                            id: `${Date.now()}-${i}`
                        };
                        await saveData(storeName, newItem);
                    }
                } else {
                    cardToSave.id = Date.now().toString();
                    await saveData(storeName, cardToSave);
                }

                // --- INÍCIO DA CORREÇÃO ---
                const cardRef = ref(database, 'market/' + marketCardKey);

                // Se for um item com quantidade, usamos uma transação para decrementar.
                // Caso contrário (personagem, magia, etc.), simplesmente removemos.
                if (type === 'item' && cardData.quantityToBuy) {
                    await runTransaction(cardRef, (currentData) => {
                        // Se o item já foi removido por outra pessoa, currentData será null.
                        if (!currentData) {
                            return; // Aborta a transação.
                        }

                        // Decrementa a quantidade no mercado.
                        currentData.quantity -= cardData.quantityToBuy;

                        // Se a quantidade restante for 0 ou menos, remove o item do mercado.
                        if (currentData.quantity <= 0) {
                            return null; // Retornar null em uma transação significa "deletar".
                        }

                        // Se ainda houver itens, atualiza o mercado com a nova quantidade.
                        return currentData;
                    });
                } else {
                    // Comportamento antigo para cards sem quantidade (personagens, magias)
                    await remove(cardRef);
                }
                // --- FIM DA CORREÇÃO ---

                showCustomAlert(`Você pegou o card "${cardData.title || cardData.name}"!`, 'success');
                takeCardModal.classList.add('hidden');
                buyItemModal.classList.add('hidden');

                switch (type) {
                    case 'character': await renderCardsAndThumbnails();
                        break;
                    case 'spell': await renderSpellCards();
                        break;
                    case 'item': await renderItemsAndThumbnails();
                        break;
                }
            }

            function listenToMarket() {
                const marketRef = ref(database, 'market');
                onValue(marketRef, (snapshot) => {
                    const marketData = snapshot.val() || {};

                    // Limpa as listas
                    marketCharactersList.innerHTML = '';
                    marketSpellsList.innerHTML = '';
                    marketPaidItemsList.innerHTML = '';
                    marketFreeItemsList.innerHTML = '';

                    const mySharedCardKeys = new Set();
                    Object.entries(marketData).forEach(([key, card]) => {
                        if (card.ownerId === userId) {
                            mySharedCardKeys.add(key);
                        }
                    });

                    // Verifica se algum card meu que estava no mercado sumiu
                    const previouslyShared = JSON.parse(localStorage.getItem('mySharedCards') || '{}');
                    const currentlySharedIds = new Set(Object.values(marketData).filter(c => c.ownerId === userId).map(c => c.id));

                    Object.entries(previouslyShared).forEach(([cardId, shareInfo]) => {
                        if (shareInfo.removeFromOwnerOnTake && !currentlySharedIds.has(cardId)) {
                            handlePostTakeActions(shareInfo.cardData);
                            delete previouslyShared[cardId];
                        }
                    });
                    localStorage.setItem('mySharedCards', JSON.stringify(previouslyShared));


                    if (Object.keys(marketData).length === 0) {
                        marketCharactersList.innerHTML = '<p class="text-gray-500 col-span-full text-center">O mercado está vazio.</p>';
                        return;
                    }

                    let found = {
                        characters: false,
                        spells: false,
                        paidItems: false,
                        freeItems: false
                    };

                    Object.entries(marketData).forEach(([key, card]) => {
                        if (card.ownerId === userId) return;

                        const cardElement = createFullMarketCardElement(key, card);
                        switch (card.cardType) {
                            case 'character':
                                marketCharactersList.appendChild(cardElement);
                                found.characters = true;
                                break;
                            case 'spell':
                                marketSpellsList.appendChild(cardElement);
                                found.spells = true;
                                break;
                            case 'item':
                                if (card.price > 0) {
                                    marketPaidItemsList.appendChild(cardElement);
                                    found.paidItems = true;
                                } else {
                                    marketFreeItemsList.appendChild(cardElement);
                                    found.freeItems = true;
                                }
                                break;
                        }
                    });

                    if (!found.characters) marketCharactersList.innerHTML = '<p class="text-gray-500 col-span-full text-center">Nenhum personagem no mercado.</p>';
                    if (!found.spells) marketSpellsList.innerHTML = '<p class="text-gray-500 col-span-full text-center">Nenhuma magia no mercado.</p>';
                    if (!found.paidItems) marketPaidItemsList.innerHTML = '<p class="text-gray-500 col-span-full text-center">Nenhum item à venda.</p>';
                    if (!found.freeItems) marketFreeItemsList.innerHTML = '<p class="text-gray-500 col-span-full text-center">Nenhum item gratuito.</p>';
                });
            }

            // DESIGN OTIMIZADO DOS CARDS DO MERCADO
            function createFullMarketCardElement(key, cardData) {
                const container = document.createElement('div');
                const cardType = cardData.cardType;
                let borderColor = 'border-gray-600';
                if (cardType === 'character') borderColor = 'border-indigo-500';
                if (cardType === 'spell') borderColor = 'border-teal-500';
                if (cardType === 'item') borderColor = 'border-amber-500';

                container.className = `market-card-item bg-slate-900/70 rounded-2xl border ${borderColor} shadow-lg overflow-hidden flex flex-col h-full cursor-pointer transition-transform transform hover:scale-105`;

                let imageURL = 'https://placehold.co/160x160/1e293b/ffffff?text=?';
                if (cardData.imageBase64) {
                    imageURL = `data:${cardData.imageMimeType};base64,${cardData.imageBase64}`;
                }

                let backgroundURL = '';
                if (cardData.backgroundImageBase64) {
                    backgroundURL = `data:${cardData.backgroundMimeType};base64,${cardData.backgroundImageBase64}`;
                }

                const headerStyle = backgroundURL ? `background-image: url('${backgroundURL}'); background-size: cover; background-position: center;` : 'bg-gray-800';

                let detailsHTML = '';
                if (cardType === 'character') {
                    detailsHTML = `
                    <div class="grid grid-cols-3 gap-1 text-xs text-center">
                        <span><i class="fas fa-heart text-red-400"></i> ${cardData.attributes.vida}</span>
                        <span><i class="fas fa-flask text-blue-400"></i> ${cardData.attributes.mana}</span>
                        <span><i class="fas fa-shield-alt text-gray-400"></i> ${cardData.attributes.armadura}</span>
                    </div>`;
                } else if (cardType === 'spell') {
                    detailsHTML = `<p class="text-xs text-gray-400 text-center">Alcance: ${cardData.range || 'N/A'}</p>`;
                } else if (cardType === 'item') {
                    detailsHTML = `
                    <div class="text-xs text-gray-300 text-center">
                        <p>Carga: ${cardData.charge}</p>
                        ${cardData.damage ? `<p>Dano: ${cardData.damage}</p>` : ''}
                    </div>`;
                }

                container.innerHTML = `
                <div class="h-24 relative" style="${headerStyle}">
                    <div class="absolute inset-0 bg-black/50 flex items-center justify-center p-2">
                         <img src="${imageURL}" class="w-20 h-20 object-cover rounded-full border-2 ${borderColor}">
                    </div>
                     ${cardType === 'character' ? `<span class="absolute top-1 right-2 bg-slate-800/80 text-white text-xs px-2 py-1 rounded-full font-bold">Nvl ${cardData.level}</span>` : ''}
                </div>
                <div class="p-3 flex-grow flex flex-col justify-between">
                    <div>
                        <h4 class="font-bold text-center">${cardData.title || cardData.name}</h4>
                        <p class="text-xs text-gray-400 italic text-center mb-2">${cardData.subTitle || cardData.type || ''}</p>
                    </div>
                    ${detailsHTML}
                </div>
                <div class="bg-slate-800/50 p-2 mt-2">
                    ${cardData.price > 0 ?
                        `<div class="text-center font-bold text-amber-400">${cardData.price} 💰 <span class="text-xs text-gray-400">(x${cardData.quantity})</span></div>` :
                        `<div class="text-center font-bold text-green-400">Gratuito</div>`
                    }
                </div>
            `;

                container.addEventListener('click', () => {
                    if (cardData.price > 0 && cardData.cardType === 'item') {
                        openBuyItemModal(key, cardData);
                    } else {
                        openTakeCardModal(key, cardData);
                    }
                });
                return container;
            }

            function openTakeCardModal(key, cardData) {
                // ROTEADOR: Se for um item gratuito com quantidade maior que 1, usa o modal de quantidade.
                if (cardData.cardType === 'item' && cardData.quantity > 1) {
                    openTakeFreeItemQuantityModal(key, cardData);
                    return; // Para a execução aqui para não abrir o modal antigo.
                }

                // LÓGICA ANTIGA: Para personagens, magias, ou itens com quantidade 1.
                let imageURL = 'https://placehold.co/160x160/1e293b/ffffff?text=?';
                if (cardData.imageBase64) {
                    imageURL = `data:${cardData.imageMimeType};base64,${cardData.imageBase64}`;
                }
                takeCardPreview.innerHTML = `<img src="${imageURL}" class="w-full h-full object-cover rounded-lg">`;
                takeCardName.textContent = cardData.title || cardData.name;

                const currentConfirmBtn = document.getElementById('confirm-take-btn');
                if (!currentConfirmBtn) {
                    console.error("Botão de confirmação 'confirm-take-btn' não encontrado no modal.");
                    return;
                }
                const newConfirmBtn = currentConfirmBtn.cloneNode(true);
                currentConfirmBtn.parentNode.replaceChild(newConfirmBtn, currentConfirmBtn);

                newConfirmBtn.addEventListener('click', () => {
                    // Para itens únicos, ainda definimos a quantidade como 1 para a transação funcionar
                    if (cardData.cardType === 'item') {
                        cardData.quantityToBuy = 1;
                    }
                    takeCard(key, cardData);
                });

                cancelTakeBtn.onclick = () => takeCardModal.classList.add('hidden');
                takeCardModal.classList.remove('hidden');
            }

            async function renderMyCardsForSharing() {
                const charList = document.getElementById('my-characters-list');
                const spellList = document.getElementById('my-spells-list');
                const itemList = document.getElementById('my-items-list');
                charList.innerHTML = '';
                spellList.innerHTML = '';
                itemList.innerHTML = '';
                const marketRef = ref(database, 'market');
                onValue(marketRef, async (snapshot) => {
                    const marketData = snapshot.val() || {};
                    const mySharedIds = new Set();
                    Object.values(marketData)
                        .forEach(card => {
                            if (card.ownerId === userId) {
                                mySharedIds.add(card.id);
                            }
                        });
                    charList.innerHTML = '';
                    spellList.innerHTML = '';
                    itemList.innerHTML = '';
                    const characters = await getData(CARD_STORE_NAME);
                    if (characters && characters.length > 0) {
                        characters.forEach(char => charList.appendChild(createShareThumbnail(char, 'character', mySharedIds.has(char.id))));
                    } else {
                        charList.innerHTML = '<p class="text-gray-500 text-sm p-4">Nenhum personagem criado.</p>';
                    }
                    const spells = await getData(SPELL_STORE_NAME);
                    if (spells && spells.length > 0) {
                        spells.forEach(spell => spellList.appendChild(createShareThumbnail(spell, 'spell', mySharedIds.has(spell.id))));
                    } else {
                        spellList.innerHTML = '<p class="text-gray-500 text-sm p-4">Nenhuma magia criada.</p>';
                    }
                    const items = await getData(ITEM_STORE_NAME);
                    if (items && items.length > 0) {
                        items.forEach(item => itemList.appendChild(createShareThumbnail(item, 'item', mySharedIds.has(item.id))));
                    } else {
                        itemList.innerHTML = '<p class="text-gray-500 text-sm p-4">Nenhum item criado.</p>';
                    }
                }, {
                    once: true
                });
            }

            // THUMBNAIL DE COMPARTILHAMENTO ATUALIZADO
            function createShareThumbnail(data, type, isShared = false) {
                const thumb = document.createElement('div');
                thumb.className = 'relative w-24 h-28 rounded-lg overflow-hidden shadow-md bg-gray-800 share-list-item';
                thumb.title = `Clique para compartilhar "${data.title || data.name}"`;
                if (isShared) {
                    thumb.classList.add('is-shared');
                    thumb.title = `Clique para remover "${data.title || data.name}" do mercado`;
                }
                let imageURL = 'https://placehold.co/60x60/4b5563/ffffff?text=?';
                if (data.image) imageURL = URL.createObjectURL(bufferToBlob(data.image, data.imageMimeType));
                let borderColor = 'border-gray-500';
                if (type === 'character') borderColor = 'border-indigo-500';
                if (type === 'spell') borderColor = 'border-teal-500';
                if (type === 'item') borderColor = 'border-amber-500';
                thumb.innerHTML = `
                    <div class="w-full h-full flex flex-col items-center justify-center p-2 text-center">
                        <img src="${imageURL}" class="w-12 h-12 object-cover rounded-full border-2 ${borderColor} mb-1">
                        <p class="text-white text-xs font-bold leading-tight" style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis; width: 75%;">${data.title || data.name}</p>
                    </div>
                    <div class="progress-overlay">
                        <i class="fas fa-check-circle success-icon"></i>
                    </div>
                `;
                thumb.addEventListener('click', () => {
                    if (thumb.classList.contains('is-shared')) {
                        removeFromMarket(data.id, thumb);
                    } else {
                        handleShareClick(data, type, thumb);
                    }
                });
                return thumb;
            }

            function handleShareClick(cardData, type, element) {
                currentCardToShare = {
                    data: cardData,
                    type: type,
                    element: element
                };
                if (type === 'item') {
                    shareItemModal.classList.remove('hidden');
                } else {
                    const modalText = `Deseja publicar "${cardData.title || cardData.name}" no mercado?`;
                    const checkboxLabel = "Remover da minha coleção após ser pego?";
                    openConfirmModal(modalText, checkboxLabel, (options) => {
                        shareCard(cardData.id, type, element, options);
                    });
                }
            }

            // NOVO: MODAIS DE CONFIRMAÇÃO E COMPRA
            function openConfirmModal(text, checkboxLabel, onConfirm) {
                document.getElementById('confirm-modal-text').textContent = text;
                const checkbox = document.getElementById('confirm-modal-checkbox');
                const checkboxLabelEl = document.getElementById('confirm-modal-checkbox-label');

                checkboxLabelEl.textContent = checkboxLabel;
                checkbox.checked = false;

                confirmModal.classList.remove('hidden');

                const yesBtn = document.getElementById('confirm-modal-yes-btn');
                const noBtn = document.getElementById('confirm-modal-no-btn');

                const newYesBtn = yesBtn.cloneNode(true);
                yesBtn.parentNode.replaceChild(newYesBtn, yesBtn);

                newYesBtn.addEventListener('click', () => {
                    onConfirm({
                        removeFromOwnerOnTake: checkbox.checked
                    });
                    confirmModal.classList.add('hidden');
                });
                noBtn.onclick = () => confirmModal.classList.add('hidden');
            }

            shareItemForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                if (!currentCardToShare) return;

                const price = parseInt(document.getElementById('share-item-price').value) || 0;
                const quantity = parseInt(document.getElementById('share-item-quantity').value) || 1;
                const removeFromOwner = document.getElementById('share-item-remove-after').checked;

                const {
                    data,
                    type,
                    element
                } = currentCardToShare;

                await shareCard(data.id, type, element, {
                    price,
                    quantity,
                    removeFromOwnerOnTake: removeFromOwner
                });

                shareItemModal.classList.add('hidden');
                shareItemForm.reset();
                currentCardToShare = null;
            });

            cancelShareItemBtn.addEventListener('click', () => {
                shareItemModal.classList.add('hidden');
                shareItemForm.reset();
            });

            async function openBuyItemModal(key, cardData) {
                // Garante que os elementos de pagamento estejam sempre visíveis para compras reais
                document.getElementById('buy-item-modal').querySelector('h3').textContent = 'Comprar Item';
                document.getElementById('buy-total-cost').parentElement.classList.remove('hidden');
                document.getElementById('buy-character-select').parentElement.classList.remove('hidden');
                // --- FIM DO AJUSTE ---

                document.getElementById('buy-item-name').textContent = cardData.name;
                document.getElementById('buy-item-price').innerHTML = `Preço: <span class="text-amber-300 font-bold">${cardData.price} 💰</span> cada`;

                let imageURL = 'https://placehold.co/128x128/1e293b/ffffff?text=?';
                if (cardData.imageBase64) {
                    imageURL = `data:${cardData.imageMimeType};base64,${cardData.imageBase64}`;
                }
                document.getElementById('buy-item-preview').innerHTML = `<img src="${imageURL}" class="w-full h-full object-cover rounded-lg">`;

                const availableQuantity = cardData.quantity;
                document.getElementById('buy-item-available').textContent = availableQuantity;
                buyQuantityInput.max = availableQuantity;
                buyQuantityInput.value = 1;

                const updateTotal = () => {
                    const quantity = parseInt(buyQuantityInput.value) || 0;
                    const total = quantity * cardData.price;
                    buyTotalCost.textContent = total;
                };
                buyQuantityInput.addEventListener('input', updateTotal);
                updateTotal();

                const myCharacters = await getData(CARD_STORE_NAME);
                buyCharacterSelect.innerHTML = myCharacters.length > 0 ? '' : '<option>Nenhum personagem seu encontrado</option>';
                myCharacters.forEach(char => {
                    const option = document.createElement('option');
                    option.value = char.id;
                    option.textContent = `${char.title} (${char.dinheiro || 0} 💰)`;
                    buyCharacterSelect.appendChild(option);
                });

                const newConfirmBtn = document.getElementById('confirm-buy-btn').cloneNode(true);
                document.getElementById('confirm-buy-btn').parentNode.replaceChild(newConfirmBtn, document.getElementById('confirm-buy-btn'));

                newConfirmBtn.addEventListener('click', async () => {
                    const selectedCharId = buyCharacterSelect.value;
                    const quantityToBuy = parseInt(buyQuantityInput.value);
                    const totalCost = quantityToBuy * cardData.price;

                    if (!selectedCharId || myCharacters.length === 0) {
                        showCustomAlert("Você precisa de um personagem para comprar.");
                        return;
                    }

                    const character = await getData(CARD_STORE_NAME, selectedCharId);
                    if ((character.dinheiro || 0) < totalCost) {
                        showCustomAlert("Dinheiro insuficiente no personagem selecionado.");
                        return;
                    }

                    character.dinheiro -= totalCost;
                    await saveData(CARD_STORE_NAME, character);

                    cardData.quantityToBuy = quantityToBuy;
                    await takeCard(key, cardData);
                });

                document.getElementById('cancel-buy-btn').onclick = () => buyItemModal.classList.add('hidden');
                buyItemModal.classList.remove('hidden');
            }

            showShareBtn.addEventListener('click', showShareView);
            async function showLinkViewForCharacter(characterId, viewType) {
                const characters = await getData(CARD_STORE_NAME);
                const character = characters.find(c => c.id === characterId);
                if (!character) return;
                hideAllSections();
                linkSection.classList.remove('hidden');
                updateActiveNav(null);
                nav.classList.add('hidden');
                dbnav.classList.add('hidden');
                currentLinkingCharacterId = characterId;
                if (viewType === 'inventory') {
                    linkSectionTitle.textContent = `Inventário de: ${character.title}`;
                    linkSectionTitle.className = 'text-2xl font-bold text-amber-300 text-center';
                    inventoryManagementArea.classList.remove('hidden');
                    spellManagementArea.classList.add('hidden');
                    await renderInventoryManagement(characterId);
                } else {
                    linkSectionTitle.textContent = `Grimório de: ${character.title}`;
                    linkSectionTitle.className = 'text-2xl font-bold text-teal-300 text-center';
                    inventoryManagementArea.classList.add('hidden');
                    spellManagementArea.classList.remove('hidden');
                    await renderLinkedSpells(characterId);
                }
            }
            showDisplayBtn.addEventListener('click', async () => {
                showDisplayView();
                await renderCardsAndThumbnails();
            });
            showSpellDisplayBtn.addEventListener('click', showSpellDisplayView);
            showItemDisplayBtn.addEventListener('click', showItemDisplayView);
            document.querySelectorAll('.back-btn')
                .forEach(btn => {
                    btn.addEventListener('click', async () => {
                        await renderCardsAndThumbnails();
                        playMp3Sound("ziper.mp3");
                        if (!creationSection.classList.contains('hidden')) showDisplayView();
                        if (!spellCreationSection.classList.contains('hidden')) showSpellDisplayView();
                        if (!itemCreationSection.classList.contains('hidden')) showItemDisplayView();
                        if (!linkSection.classList.contains('hidden')) showDisplayView();
                        nav.classList.remove('hidden');
                        dbnav.classList.remove('hidden');
                    });
                });

            function showSplash() {
                splashScreen.classList.remove('hidden');
                mainContent.classList.add('hidden');
                nav.classList.add('hidden');
                dbnav.classList.add('hidden');
                if (loaderClipRect) loaderClipRect.setAttribute('height', '0');
                progressText.textContent = 'Iniciando aventura...';
            }

            function updateProgress(percentage, message) {
                if (loaderClipRect) {
                    const newHeight = 24 * (percentage / 100);
                    loaderClipRect.setAttribute('height', newHeight);
                }
                if (message) {
                    progressText.textContent = `${message} (${percentage}%)`;
                }
            }

            function hideSplash() {
                splashScreen.classList.add('hidden');
                mainContent.classList.remove('hidden');
                nav.classList.remove('hidden');
                dbnav.classList.remove('hidden');
            }

            function populatePericiasCheckboxes() {
                periciasCheckboxesContainer.innerHTML = '';
                for (const attribute in periciasData) {
                    const details = document.createElement('details');
                    details.className = 'bg-gray-700 rounded-lg p-2 transition-all duration-300';
                    details.innerHTML = `<summary class="flex items-center justify-between cursor-pointer font-semibold text-indigo-200"><span>${attribute}</span><svg class="w-4 h-4 transform transition-transform" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" /></svg></summary><div class="mt-2 space-y-2 pl-4 border-l border-gray-600 pericias-list"></div>`;
                    const periciasList = details.querySelector('.pericias-list');
                    details.querySelector('summary')
                        .addEventListener('click', () => {
                            setTimeout(() => {
                                details.querySelector('svg').style.transform = details.open ? 'rotate(90deg)' : 'rotate(0deg)';
                            }, 300);
                        });
                    for (const periciaName in periciasData[attribute]) {
                        const periciaItem = document.createElement('div');
                        periciaItem.className = 'flex items-center justify-between pericia-item rounded-md p-1';
                        const periciaId = `pericia-${periciaName.replace(/\s+/g, '-')}`;
                        periciaItem.innerHTML = `
                            <div class="flex items-center">
                                <input type="checkbox" id="${periciaId}" name="pericia" value="${periciaName}" class="form-checkbox h-4 w-4 text-indigo-500 rounded border-gray-600 focus:ring-indigo-500">
                                <label for="${periciaId}" class="ml-2 text-sm text-gray-200 cursor-pointer">${periciaName}</label>
                            </div>
                            <input type="number" id="${periciaId}-value" placeholder="0" class="w-16 px-2 py-1 bg-gray-800 text-white text-sm rounded-md border border-gray-600 focus:border-indigo-500">
                        `;
                        periciasList.appendChild(periciaItem);
                        periciaItem.querySelector('label')
                            .addEventListener('click', (e) => {
                                periciaDescriptionTitle.textContent = periciaName;
                                periciaDescriptionText.textContent = periciasData[attribute][periciaName];
                                periciaDescriptionDisplay.classList.remove('hidden');
                            });
                    }
                    periciasCheckboxesContainer.appendChild(details);
                }
            }
            let currentEditingCardId = null;
            let currentEditingSpellId = null;
            let currentEditingItemId = null;
            let currentLinkingCharacterId = null;
            let currentStatusEditingCardId = null;
            let currentStoreForImport = null;
            let db;
            const DB_NAME = 'rpgCreatorDB',
                DB_VERSION = 11;
            const CARD_STORE_NAME = 'rpgCards';
            const SPELL_STORE_NAME = 'rpgSpells';
            const ITEM_STORE_NAME = 'rpgItems';
            let characterImageFile = null,
                backgroundImageFile = null,
                spellImageFile = null,
                itemImageFile = null;

            function bufferToBlob(buffer, mimeType) {
                return new Blob([buffer], {
                    type: mimeType
                });
            }

            function arrayBufferToBase64(buffer) {
                let binary = '';
                const bytes = new Uint8Array(buffer);
                const len = bytes.byteLength;
                for (let i = 0; i < len; i++) {
                    binary += String.fromCharCode(bytes[i]);
                }
                return window.btoa(binary);
            }

            function base64ToArrayBuffer(base64) {
                const binary_string = window.atob(base64);
                const len = binary_string.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binary_string.charCodeAt(i);
                }
                return bytes.buffer;
            }

            function rgbToHsl(r, g, b) {
                r /= 255;
                g /= 255;
                b /= 255;
                let max = Math.max(r, g, b),
                    min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;
                if (max === min) {
                    h = s = 0;
                } else {
                    let d = max - min;
                    s = l > 0.5 ?
                        d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r:
                            h = (g - b) / d + (g < b ? 6 : 0);
                            break;
                        case g:
                            h = (b - r) / d + 2;
                            break;
                        case b:
                            h = (r - g) / d + 4;
                            break;
                    }
                    h /= 6;
                }
                return [h, s, l];
            }

            function hslToRgb(h, s, l) {
                let r, g, b;
                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1 / 6) return p + (q - p) * 6 * t;
                        if (t < 1 / 2) return q;
                        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                        return p;
                    };
                    const q = l < 0.5 ?
                        l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1 / 3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1 / 3);
                }
                return `rgb(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)})`;
            }

            function getPredominantColorAndPalette(imageUrl) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0, img.width, img.height);
                        try {
                            const imageData = ctx.getImageData(0, 0, img.width, img.height)
                                .data;
                            let r = 0,
                                g = 0,
                                b = 0,
                                count = 0;
                            const step = 4 * 10;
                            for (let i = 0; i < imageData.length; i += step) {
                                r += imageData[i];
                                g += imageData[i + 1];
                                b += imageData[i +
                                    2];
                                count++;
                            }
                            const avgR = Math.floor(r / count),
                                avgG = Math.floor(g / count),
                                avgB = Math.floor(b / count);
                            let [h, s, l] = rgbToHsl(avgR, avgG, avgB);
                            const isLight = l > 0.5;
                            resolve({
                                cardBg: isLight ? 'rgba(255, 255, 255, 0.8)' : 'rgba(31, 41, 55, 0.9)',
                                highlightColor: hslToRgb(h, Math.min(s * 1.5, 1), isLight ? Math.max(l * 0.7, 0.3) : Math.min(l * 1.5, 0.7)),
                                textColor: isLight ? 'rgb(31, 41, 55)' : 'rgb(243, 244, 246)',
                                borderColor: hslToRgb(h, s, isLight ?
                                    Math.max(l * 0.7, 0.3) : Math.min(l * 1.5, 0.7))
                            });
                        } catch (e) {
                            reject(e);
                        }
                    };
                    img.onerror = (e) => reject(e);
                    img.src = imageUrl;
                });
            }

            function openDatabase() {
                return new Promise((resolve, reject) => {
                    const req = indexedDB.open(DB_NAME, DB_VERSION);
                    req.onsuccess = (e) => {
                        db = e.target.result;
                        resolve(db);
                    };
                    req.onerror = (e) => reject(e.target.error);
                    req.onupgradeneeded = (e) => {
                        db = e.target.result;
                        if (!db.objectStoreNames.contains(CARD_STORE_NAME)) {
                            db.createObjectStore(CARD_STORE_NAME, {
                                keyPath: 'id'
                            });
                        }
                        if (!db.objectStoreNames.contains(SPELL_STORE_NAME)) {
                            db.createObjectStore(SPELL_STORE_NAME, {
                                keyPath: 'id'
                            });
                        }
                        if (!db.objectStoreNames.contains(ITEM_STORE_NAME)) {
                            db.createObjectStore(ITEM_STORE_NAME, {
                                keyPath: 'id'
                            });
                        }
                    };
                });
            }
            async function saveData(storeName, data) {
                const tx = db.transaction([storeName], 'readwrite');
                const store = tx.objectStore(storeName);
                return new Promise((resolve, reject) => {
                    const req = store.put(data);
                    req.onsuccess = () => resolve();
                    req.onerror = (e) => reject(e.target.error);
                });
            }
            async function getData(storeName, key) {
                const tx = db.transaction([storeName], 'readonly');
                const store = tx.objectStore(storeName);
                const request = key ? store.get(key) : store.getAll();
                return new Promise((resolve, reject) => {
                    request.onsuccess = (e) => resolve(e.target.result);
                    request.onerror = (e) => reject(e.target.error);
                });
            }
            async function removeData(storeName, id) {
                const tx = db.transaction([storeName], 'readwrite');
                const store = tx.objectStore(storeName);
                return new Promise((resolve, reject) => {
                    const req = store.delete(id);
                    req.onsuccess = () => resolve();
                    req.onerror = (e) => reject(e.target.error);
                });
            }
            async function editCard(cardId) {
                const cardData = await getData(CARD_STORE_NAME, cardId);
                if (!cardData) return;
                showCreationView(true);
                formTitle.textContent = `Editando: ${cardData.title}`;
                currentEditingCardId = cardId;
                cardTitleInput.value = cardData.title;
                cardSubTitleInput.value = cardData.subTitle;
                cardLevelInput.value = cardData.level;
                dinheiroInput.value = cardData.dinheiro;
                if (cardData.lore) {
                    historiaInput.value = cardData.lore.historia ||
                        '';
                    personalidadeInput.value = cardData.lore.personalidade || '';
                    motivacaoInput.value = cardData.lore.motivacao || '';
                }
                vidaInput.value = cardData.attributes.vida;
                manaInput.value = cardData.attributes.mana;
                vidaAtualInput.value = cardData.attributes.vidaAtual;
                manaAtualInput.value = cardData.attributes.manaAtual;
                armaduraInput.value = cardData.attributes.armadura;
                esquivaInput.value = cardData.attributes.esquiva;
                bloqueioInput.value = cardData.attributes.bloqueio;
                deslocamentoInput.value = cardData.attributes.deslocamento;
                agilidadeInput.value = cardData.attributes.agilidade;
                carismaInput.value = cardData.attributes.carisma;
                forcaInput.value = cardData.attributes.forca;
                inteligenciaInput.value = cardData.attributes.inteligencia;
                sabedoriaInput.value = cardData.attributes.sabedoria;
                vigorInput.value = cardData.attributes.vigor;
                populatePericiasCheckboxes();
                document.querySelectorAll('.pericia-item input[type="checkbox"]')
                    .forEach(cb => cb.checked = false);
                if (Array.isArray(cardData.attributes.pericias)) {
                    cardData.attributes.pericias.forEach(pericia => {
                        const periciaId = `pericia-${pericia.name.replace(/\s+/g, '-')}`;
                        const checkbox = document.getElementById(periciaId);
                        const valueInput = document.getElementById(`${periciaId}-value`);
                        if (checkbox) checkbox.checked = true;
                        if (valueInput) valueInput.value = pericia.value;
                    });
                }
                if (cardData.image) {
                    const imageBlob = bufferToBlob(cardData.image, cardData.imageMimeType);
                    showImagePreview(characterImagePreview, URL.createObjectURL(imageBlob), true);
                    characterImageFile = null;
                } else {
                    showImagePreview(characterImagePreview, null, true);
                }
                if (cardData.backgroundImage) {
                    const backgroundBlob = bufferToBlob(cardData.backgroundImage, cardData.backgroundMimeType);
                    showImagePreview(backgroundImagePreview, URL.createObjectURL(backgroundBlob), false);
                } else {
                    showImagePreview(backgroundImagePreview, null, false);
                }
                characterImageUpload.value = null;
                backgroundImageUpload.value = null;
                submitButton.textContent = 'Salvar Edição';
                submitButton.classList.remove('btn-gradient-pulse');
            }

            function createAddThumbnail(type) {
                const container = document.createElement('div');
                container.className = 'flex flex-col items-center justify-center';
                let colorClass = 'border-indigo-500 hover:bg-indigo-500';
                let importColorClass = 'bg-indigo-500 hover:bg-indigo-600';
                let storeName = CARD_STORE_NAME;

                if (type === 'spell') {
                    colorClass = 'border-teal-500 hover:bg-teal-500';
                    importColorClass = 'bg-teal-500 hover:bg-teal-600';
                    storeName = SPELL_STORE_NAME;
                }
                if (type === 'item') {
                    colorClass = 'border-amber-500 hover:bg-amber-500';
                    importColorClass = 'bg-amber-500 hover:bg-amber-600';
                    storeName = ITEM_STORE_NAME;
                }

                const addThumb = document.createElement('div');
                addThumb.className = `relative w-20 h-24 rounded-lg flex items-center justify-center border-2 border-dashed ${colorClass} cursor-pointer transition-colors duration-200`;
                addThumb.style.minWidth = '5rem';
                addThumb.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" /></svg>`;
                const importBtn = document.createElement('button');
                importBtn.className = `absolute -bottom-2 thumb-btn ${importColorClass}`;
                importBtn.title = 'Importar JSON';
                importBtn.innerHTML = `<i class="fas fa-upload"></i>`;
                let addClickHandler;

                if (type === 'character') addClickHandler = () => showCreationView(false);
                if (type === 'spell') addClickHandler = () => showSpellCreationView(false);
                if (type === 'item') addClickHandler = () => showItemCreationView(false);

                addThumb.addEventListener('click', addClickHandler);
                importBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    initiateImport(storeName);
                });
                addThumb.appendChild(importBtn);
                container.appendChild(addThumb);
                return container;
            }
            async function renderCardsAndThumbnails() {
                thumbnailList.innerHTML = '';
                thumbnailList.appendChild(createAddThumbnail('character'));
                const allCards = await getData(CARD_STORE_NAME);
                if (allCards.length === 0) {
                    cardDisplayArea.innerHTML = '<p class="text-gray-400 text-center">Nenhum personagem encontrado. Clique no botão + para criar um.</p>';
                } else {
                    cardDisplayArea.innerHTML = '<p class="text-gray-400">Selecione um personagem na lista acima para ver os detalhes.</p>';
                }
                let cardsLoaded = 0;
                for (const cardData of allCards) {
                    let imageURL = 'https://placehold.co/160x160/E5E7EB/4B5563?text=Personagem';
                    let backgroundURL = 'https://placehold.co/400x600/1e293b/d1d5db?text=Fundo';
                    if (cardData.image) imageURL = URL.createObjectURL(bufferToBlob(cardData.image, cardData.imageMimeType));
                    if (cardData.backgroundImage) backgroundURL = URL.createObjectURL(bufferToBlob(cardData.backgroundImage, cardData.backgroundMimeType));
                    const thumbnail = createThumbnailElement({
                        ...cardData,
                        imageURL,
                        backgroundURL
                    }, CARD_STORE_NAME);
                    thumbnailList.appendChild(thumbnail);
                    cardsLoaded++;
                    const percentage = Math.round((cardsLoaded / allCards.length) * 33);
                    updateProgress(percentage, loadingMessages[Math.floor(Math.random() * loadingMessages.length)]);
                }

                if (allCards.length > 0) {
                    await displayCard(allCards[0].id);
                }
            }
            async function displayCard(cardId) {
                cardDisplayArea.innerHTML = '';
                const fullCardData = await getData(CARD_STORE_NAME, cardId);
                if (!fullCardData) return;
                let imageURL = 'https://placehold.co/160x160/E5E7EB/4B5563?text=Personagem';
                let backgroundURL = 'https://placehold.co/400x600/1e293b/d1d5db?text=Fundo';
                if (fullCardData.image) imageURL = URL.createObjectURL(bufferToBlob(fullCardData.image, fullCardData.imageMimeType));
                if (fullCardData.backgroundImage) backgroundURL = URL.createObjectURL(bufferToBlob(fullCardData.backgroundImage, fullCardData.backgroundMimeType));
                const cardElement = await createCardElement({
                    ...fullCardData,
                    imageURL,
                    backgroundURL
                });
                cardDisplayArea.appendChild(cardElement);
                setTimeout(() => cardElement.classList.add('visible'), 10);
                await updateSidebarsContent(cardElement.querySelector('.rpg-card'), cardId);
                updateHeartVisuals(fullCardData.attributes.vidaAtual, fullCardData.attributes.vida);
                updatePotionVisuals(fullCardData.attributes.manaAtual, fullCardData.attributes.mana);

                // --- ADICIONE ESTA LINHA ---
                updateSendToTableButtonState(cardId);
                // --- FIM DA LINHA ADICIONADA ---
            }
            async function createCardElement(cardData) {
                const cardWrapper = document.createElement('div');
                cardWrapper.className = 'card-wrapper flex flex-col items-center gap-4';
                const cardDiv = document.createElement('div');
                cardDiv.className = 'w-full h-auto rounded-3xl shadow-2xl rpg-card';
                cardDiv.dataset.cardId = cardData.id;
                cardDiv.style.backgroundImage = `url(${cardData.backgroundURL})`;
                let palette = {
                    cardBg: 'rgba(31,41,55,0.9)',
                    highlightColor: '#6366f1',
                    textColor: '#e5e7eb',
                    borderColor: '#4b5563'
                };
                if (cardData.backgroundURL && !cardData.backgroundURL.includes('placehold.co')) {
                    try {
                        palette = await getPredominantColorAndPalette(cardData.backgroundURL);
                    } catch (e) {
                        console.error('Falha ao gerar paleta.', e);
                    }
                }
                let periciasHtml = '<p class="text-xs text-gray-400 italic">Nenhuma perícia selecionada.</p>';
                if (Array.isArray(cardData.attributes.pericias) && cardData.attributes.pericias.length > 0) {
                    const groupedPericias = cardData.attributes.pericias.reduce((acc, pericia) => {
                        const className = pericia.class || 'Outras';
                        if (!acc[className]) acc[className] = [];
                        acc[className].push(pericia);
                        return acc;
                    }, {});
                    const sortedClasses = Object.keys(groupedPericias)
                        .sort();
                    periciasHtml = sortedClasses.map(className => {
                        const periciasList = groupedPericias[className].map(p => `<span class="text-xs text-gray-400 italic">${p.name} +${p.value}; </span>`)
                            .join('');
                        return `<div class="text-left mt-1"><p class="text-xs text-gray-400 italic" style="font-size: 11px;">${className}</p><div class="flex flex-wrap gap-1 mb-1">${periciasList}</div></div>`;
                    })
                        .join('');
                }
                var imgIs = cardData.backgroundURL.includes('placehold.co');
                const mainAttributes = ['agilidade', 'carisma', 'forca', 'inteligencia', 'sabedoria', 'vigor'];
                const attributeValues = mainAttributes.map(attr => parseInt(cardData.attributes[attr]) || 0);
                const maxAttributeValue = Math.max(...attributeValues, 1);
                const cdValue = 10 + (parseInt(cardData.level) || 0) + (parseInt(cardData.attributes.sabedoria) || 0);
                cardDiv.innerHTML = `
                    <div class="card-3d-container">
                       <div class="nebula-sky">
                            <div class="parallax-container"  style="opacity: ${!imgIs ? '0' : '1'}">
                                <div id="nebula-bg" class="stars-layer"></div>
                                <div id="stars-far" class="stars-layer"></div>
                                <div id="stars-medium" class="stars-layer"></div>
                                <div id="stars-near" class="stars-layer"></div>
                            </div>
                            <div id="glow-overlay"></div>
                            <div class="card-3d">                                 
                                <div class="card-front" style="border-color: ${palette.borderColor}">
                                <div class="rounded-3xl relative w-full h-full p-4 ex-max" style="background-image:${!imgIs ? `url(${cardData.backgroundURL})` : 'transparent'} !important; height: 700px; display: flex; flex-direction: column; align-items: center; background-color: rgb(0 0 0 / 50%); justify-content: space-between; background-position: center;">
                                    <div id="spell-sidebar" class="sidebar sidebar-left">
                                        <div class="sidebar-content">
                                            <div class="items-center justify-center gap-2 mb-4" style="margin-right: -40px; display: flex; flex-direction: column;">
                                                <h4 class="sidebar-title" style="margin: 0">Grimório</h4>
                                                <button class="manage-btn-sidebar" data-action="manage-spells" title="Gerenciar Grimório"><i class="fas fa-book-open" style="font-size: 20px;"></i></button>
                                            </div>
                                            <div id="spell-sidebar-content" class="sidebar-list" style="margin-right: -40px; direction: rtl;"></div>
                                        </div>
                                        <button class="sidebar-toggle" style="background: rgb(20 184 166 / var(--tw-border-opacity, 1))"><i class="fas fa-chevron-right"></i></button>
                                    </div>
                                    <div id="item-sidebar" class="sidebar sidebar-right">
                                        <button class="sidebar-toggle" style="background: rgb(245 158 11 / var(--tw-border-opacity, 1));"><i class="fas fa-chevron-left"></i></button>
                                        <div class="sidebar-content">
                                            <div class="items-center justify-center gap-2 mb-4" style="margin-left: -40px; display: flex; flex-direction: column;">
                                                <h4 class="sidebar-title" style="margin: 0">Inventário</h4>
                                                <button class="manage-btn-sidebar" data-action="manage-inventory" title="Gerenciar Inventário"><i class="fas fa-box" style="font-size: 20px;"></i></button>
                                            </div>
                                            <div id="item-sidebar-content" class="sidebar-list" style="margin-left: -40px;"></div>
                                        </div>
                                    </div>
                                    <div class="absolute top-4 left-2 rounded-full w-14 h-14 flex items-center justify-center font-bold" data-action="open-status-modal" data-local="mana" title="Alterar Mana">
                                        <div class="icon-container potion-container">
                                            <svg class="potion-svg" viewBox="0 0 50 50">
                                                <defs>
                                                <clipPath id="potion-mask-${cardData.id}">
                                                    <path d="M18,15 V5 h14 v10 a17,17 0 1,1 -14,0 z" />
                                                </clipPath>
                                                </defs>
                                                <g clip-path="url(#potion-mask-${cardData.id})">
                                                <rect class="potion-liquid" x="8" y="5" width="34" height="45" />
                                                <circle class="bubble" cx="20" cy="45" r="2.5" data-base-radius="2.5"/>
                                                <circle class="bubble" cx="28" cy="42" r="2" data-base-radius="2"/>
                                                <circle class="bubble" cx="33" cy="46" r="1.5" data-base-radius="1.5"/>
                                                </g>
                                                <path class="potion-glass" d="M18,15 V5 h14 v10 a17,17 0 1,1 -14,0 z" />
                                                <rect class="potion-cork" x="18" y="0" width="14" height="5" rx="2" />
                                            </svg>
                                            <div class="status-text-container status-fraction text-lg" style="transform: scale(.5);">
                                                <span data-status="mana">${cardData.attributes.manaAtual || '?'}</span><span class="fraction-line" style="width: 50%;"></span><span>${cardData.attributes.mana || '?'}</span>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="absolute top-2 right-2 rounded-full w-14 h-14 flex items-center justify-center font-bold" data-action="open-status-modal" data-local="life" title="Alterar Vida">
                                        <div class="icon-container heart-container">
                                            <svg class="heart-svg" viewBox="0 0 24 24">
                                                <path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/>
                                            </svg>
                                            <div class="status-text-container status-fraction text-lg" style="transform: scale(.5);">
                                                <span data-status="life">${cardData.attributes.vidaAtual || '?'}</span><span class="fraction-line" style="width: 50%;"></span><span>${cardData.attributes.vida || '?'}</span>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="absolute top-20 left-4 rounded-full p-3 bg-black/50 flex items-center justify-center text-lg text-yellow-200 cursor-pointer" data-action="toggle-lore" title="Ver História">
                                        <i class="fas fa-book"></i>
                                    </div>
                                    <div class="absolute money-container top-36 left-4 rounded-full p-2 bg-black/50 flex items-center justify-center text-sm text-amber-300 font-bold" data-action="open-status-modal"  data-local="money" title="Alterar Dinheiro" style=" writing-mode: vertical-rl; text-orientation: upright;">
                                        💰$<span data-status="money">${cardData.dinheiro || 0}</span>
                                    </div>
                                    <div class="text-center" style="width: 60%;">
                                        <h3 class="text-2xl font-bold" style="color: ${palette.highlightColor};">${cardData.title}</h3>
                                        <div class="rpg-card-title-divider" style="background: linear-gradient(to right, transparent, ${palette.borderColor}, transparent); width: 100%"></div>
                                        <p class="text-sm italic" style="color: ${palette.highlightColor};">${cardData.subTitle}</p>
                                        <p class="text-sm italic" style="color: ${palette.highlightColor};">${cardData.level}</p>
                                    </div>
                                    <div class="wave-container flex justify-center img-max" style="position: relative; width: 180px !important; height: 180px;"><img style="border-color: ${palette.borderColor}; z-index: 1; height: 180px" src="${cardData.imageURL}" onerror="this.src='https://placehold.co/160x160/E5E7EB/4B5563?text=Personagem';" alt="Imagem do personagem" class="object-cover rounded-full border-4 border-white shadow-lg w-full h-full"></div>
                                    <button id="send-to-table-btn" data-action="send-to-table" class="py-2 px-4 mt-3 rounded-full text-sm font-bold text-white transition-colors flex items-center gap-2 z-10">
                                        <i class="fas fa-dungeon" style="font-size: 25px;"></i>
                                    </button>
                                    <div class="p-3 rounded-3xl text-center w-full rpg-card-frame" style="--card-bg-color: ${palette.cardBg}; z-index: 1; --text-color: ${palette.textColor}; --border-color: ${palette.borderColor};">
                                        <div class="grid grid-cols-5 gap-x-4 gap-y-1 text-xs my-2 mb-4">
                                            <div class="text-center">CA<br>${cardData.attributes.armadura || 0}</div>
                                            <div class="text-center">ES<br>${cardData.attributes.esquiva || 0}</div>
                                            <div class="text-center">BL<br>${cardData.attributes.bloqueio || 0}</div>
                                            <div class="text-center">DL<br>${cardData.attributes.deslocamento || 0}m</div>
                                            <div class="text-center font-bold text-indigo-300">CD<br>${cdValue}</div>
                                        </div>
                                        ${mainAttributes.map(key => {
                    const value = parseInt(cardData.attributes[key]) || 0; const percentage = maxAttributeValue > 0 ? (value * 100) / maxAttributeValue : 0;
                    return `
                                            <div class="mt-2 flex items-center space-x-2 text-xs">
                                                <span class="font-bold w-8">${key.slice(0, 3).toUpperCase()}</span>
                                                <div class="stat-bar flex-grow" style="margin-top: 0">
                                                    <div class="stat-fill" style="width: ${percentage}%; background: ${palette.borderColor}"></div>
                                                </div>
                                                <span class="text-xs font-bold ml-auto">${value} / ${maxAttributeValue}</span>
                                            </div>
                                            `;
                }).join('')}
                                        <div class="pericias-scroll-area flex flex-col gap-2 mt-2" style="max-height: 100px; overflow-y: auto;">
                                            <div class="flex items-center justify-center w-full"></div>
                                            ${periciasHtml}
                                        </div>
                                    </div>
                                    <div class="lore-card" data-action="toggle-lore">
                                        <h4 style="color: ${palette.highlightColor}; border-color: ${palette.borderColor};">História</h4>
                                        <p style="text-align:justify;white-space:pre-line;overflow-wrap:break-word;">${cardData.lore?.historia || 'Nenhuma história definida.'}</p>
                                        <h4 class="mt-4" style="color: ${palette.highlightColor}; border-color: ${palette.borderColor};">Personalidade</h4>
                                        <p style="text-align:justify;white-space:pre-line;overflow-wrap:break-word;">${cardData.lore?.personalidade || 'Nenhuma personalidade definida.'}</p>
                                        <h4 class="mt-4" style="color: ${palette.highlightColor}; border-color: ${palette.borderColor};">Motivação</h4>
                                        <p style="text-align:justify;white-space:pre-line;overflow-wrap:break-word;">${cardData.lore?.motivacao || 'Nenhuma motivação definida.'}</p>
                                    </div>
                                    </div>
                                </div>
                                <div class="card-back divPartculas" style="background-image:${!imgIs ? `url(${cardData.backgroundURL})` : 'transparent'} !important; background-size: cover !important; background-color: rgb(0 0 0 / 50%);background-blend-mode: multiply; background-position: center;">
                                    <div class="back-content p-4 text-left" style="display: flex; border: 5px solid ${palette.borderColor}; align-items: center; justify-content: center;">
                                    <i class="fas fa-shield-halved" style="font-size: 200px; opacity: 1; color: ${palette.borderColor}"></i>                                
                                    </div>
                                </div>
                            </div>
                        </div>
                        </div>`;
                cardWrapper.appendChild(cardDiv);
                const card3d = cardDiv.querySelector('.card-3d');
                if (card3d) {
                    card3d.addEventListener('click', (e) => {
                        if (e.target.closest('[data-action]') || e.target.closest('.sidebar')) return;
                        card3d.style.transform = card3d.style.transform === 'rotateY(180deg)' ? 'rotateY(0deg)' : 'rotateY(180deg)';
                    });
                }
                const spellSidebar = cardDiv.querySelector('#spell-sidebar');
                const itemSidebar = cardDiv.querySelector('#item-sidebar');
                if (spellSidebar) {
                    spellSidebar.querySelector('.sidebar-toggle')
                        .addEventListener('click', (e) => {
                            e.stopPropagation();
                            spellSidebar.classList.toggle('expanded');
                        });
                }
                if (itemSidebar) {
                    itemSidebar.querySelector('.sidebar-toggle')
                        .addEventListener('click', (e) => {
                            e.stopPropagation();
                            itemSidebar.classList.toggle('expanded');
                        });
                }
                cardDiv.addEventListener('click', async (e) => {
                    const itemEl = e.target.closest('.sidebar-item');
                    if (!itemEl) return;
                    const type = itemEl.dataset.type;
                    const templateId = itemEl.dataset.templateId;
                    let itemData;
                    if (type === 'item') {
                        itemData = await getData(ITEM_STORE_NAME, templateId);
                    } else {
                        itemData = await getData(SPELL_STORE_NAME, templateId);
                    }
                    if (itemData) {
                        await showExpandedCardInModal(itemData, type, cardData.id);
                    }
                });

                // Coloque este código dentro do script principal em index.html

                // No seu arquivo index.html, encontre esta função e modifique-a

                // --- ADICIONE ESTE NOVO BLOCO ---
                document.addEventListener('click', async (e) => {
                    const sendToTableBtn = e.target.closest('#send-to-table-btn');
                    if (sendToTableBtn) {
                        const cardElement = sendToTableBtn.closest('.rpg-card');
                        if (!cardElement) return;

                        const charId = cardElement.dataset.cardId;

                        // Verifica se tem a classe 'on-table' para decidir a ação
                        if (sendToTableBtn.classList.contains('on-table')) {
                            // Se sim, remove o personagem
                            if (confirm('Tem certeza que deseja remover este personagem da mesa?')) {
                                await removeCharacterFromTable(charId);
                            }
                        } else {
                            // Se não, envia o personagem (função que já existia)
                            await seddManalife(charId);
                        }
                    }
                });

                // Função para remover do Firebase a partir do index.html
                async function removeCharacterFromTable(charId) {
                    const { database, ref, remove } = window.firebaseDB;
                    const tableRef = ref(database, `gameTables/default-table/characters/${charId}`);
                    try {
                        await remove(tableRef);
                        showCustomAlert("Removido!", 'success');
                    } catch (error) {
                        console.error("Erro ao remover da mesa:", error);
                        showCustomAlert("Falha ao remover o personagem da mesa.");
                    }
                }
                // --- FIM DO NOVO BLOCO ---

                async function seddManalife(cardId) {
                    const characterData = await getData(CARD_STORE_NAME, cardId);

                    if (!characterData) {
                        showCustomAlert("Personagem não encontrado!");
                        return;
                    }

                    // 1. Prepara os dados para enviar ao Firebase (SEM A IMAGEM)
                    const dataForTable = {
                        id: characterData.id,
                        name: characterData.title,
                        currentLife: characterData.attributes.vidaAtual,
                        maxLife: characterData.attributes.vida,
                        currentMana: characterData.attributes.manaAtual,
                        maxMana: characterData.attributes.mana,
                        money: characterData.dinheiro
                        // REMOVEMOS AS LINHAS imageBase64 e imageMimeType daqui
                    };

                    // 2. REMOVA OU COMENTE TODO ESTE BLOCO 'if' QUE CONVERTE A IMAGEM
                    /*
                    if (characterData.image) {
                        dataForTable.imageBase64 = `data:${characterData.imageMimeType};base64,${arrayBufferToBase64(characterData.image)}`;
                    }
                    */

                    // 3. Define a referência no Firebase Realtime Database
                    const tableRef = ref(database, `gameTables/default-table/characters/${characterData.id}`);

                    // 4. Envia os dados
                    try {
                        await set(tableRef, dataForTable);
                        showCustomAlert(`enviado`, 'success');
                    } catch (error) {
                        console.error("Erro ao enviar para a mesa:", error);
                        showCustomAlert("Falha ao conectar com a mesa.");
                    }
                }
                // --- INÍCIO DA SOLUÇÃO ---
                // Lista de seletores para todas as áreas que precisam de rolagem independente.
                const scrollableAreas = [
                    '#spell-sidebar-content', // Sidebar de Magias (Grimório)
                    '#item-sidebar-content',  // Sidebar de Itens (Inventário)
                    '.pericias-scroll-area',   // Área de rolagem das Perícias
                    '.lore-card'               // Card de História/Lore que também pode ter scroll
                ];

                scrollableAreas.forEach(selector => {
                    const element = cardDiv.querySelector(selector);
                    if (element) {
                        // Impede que eventos de clique e toque "borbulhem" para o container do parallax.
                        ['mousedown', 'touchstart'].forEach(eventType => {
                            element.addEventListener(eventType, (e) => {
                                e.stopPropagation();
                            });
                        });
                    }
                });
                // --- FIM DA SOLUÇÃO ---


                const nebulaContainer = cardDiv.querySelector('.nebula-sky');
                if (nebulaContainer) {
                    initializeNebulaEffect(nebulaContainer);
                }
                return cardWrapper;
            }

            // Cole esta nova função dentro do script principal do index.html

            /**
             * Inicia a escuta por atualizações na mesa de jogo do Firebase
             * e sincroniza os dados de volta para o IndexedDB local.
             */
            function listenForTableUpdates() {
                const {
                    database,
                    ref,
                    onValue
                } = window.firebaseDB;
                const tableRef = ref(database, 'gameTables/default-table/characters');

                // onValue fica monitorando o 'nó' de personagens na mesa
                onValue(tableRef, async (snapshot) => {
                    // CORREÇÃO: Garante que 'charactersOnTable' seja um objeto vazio ({}) se o snapshot for nulo (vazio).
                    const charactersOnTable = snapshot.val() || {};

                    // Atualiza nosso rastreador global com os IDs dos personagens na mesa.
                    // Se 'charactersOnTable' for {}, 'Object.keys' retornará um array vazio, limpando o rastreador corretamente.
                    charactersOnTableIds = new Set(Object.keys(charactersOnTable));

                    // Verifica se um card está sendo exibido e atualiza o estado do seu botão
                    const displayedCardElement = document.querySelector('.rpg-card[data-card-id]');
                    if (displayedCardElement) {
                        updateSendToTableButtonState(displayedCardElement.dataset.cardId);
                    }

                    // Itera sobre cada personagem que está na mesa para sincronizar
                    for (const charId in charactersOnTable) {
                        const tableData = charactersOnTable[charId];

                        // 1. Tenta buscar o personagem correspondente no banco de dados local
                        const localCharData = await getData(CARD_STORE_NAME, charId);

                        // Se o personagem existe localmente, prossegue com a sincronização
                        if (localCharData) {
                            let needsUpdate = false;

                            // --- INÍCIO DA CORREÇÃO ---
                            // Pega referências ao card e seus elementos de animação se ele estiver na tela
                            const cardOnScreen = document.querySelector(`.rpg-card[data-card-id="${charId}"]`);
                            let card3d, vidaIcon, manaIcon, moneyIcon;

                            if (cardOnScreen) {
                                card3d = cardOnScreen.querySelector('.nebula-sky');
                                vidaIcon = cardOnScreen.querySelector('.heart-container');
                                manaIcon = cardOnScreen.querySelector('.potion-container');
                                moneyIcon = cardOnScreen.querySelector('.money-container');
                                resetcard3d(card3d); // Limpa animações anteriores
                            }
                            // --- FIM DA CORREÇÃO ---

                            // 2. Compara os valores e marca se precisa de atualização E aciona a animação
                            if (localCharData.attributes.vidaAtual !== tableData.currentLife) {
                                // Aciona a animação apenas se o card estiver visível
                                if (cardOnScreen) {
                                    if (tableData.currentLife < localCharData.attributes.vidaAtual) {
                                        triggerCardPunch(card3d);
                                    } else {
                                        triggerCardLifeIn(card3d, vidaIcon);
                                    }
                                }
                                localCharData.attributes.vidaAtual = tableData.currentLife;
                                needsUpdate = true;
                            }

                            if (localCharData.attributes.manaAtual !== tableData.currentMana) {
                                if (cardOnScreen) {
                                    playMp3Sound('mana.mp3');
                                    if (localCharData.attributes.manaAtual > tableData.currentMana) {
                                        createManaMist(manaIcon, 'out', '#1a1a1a');
                                        card3d.classList.add('star-container', 'glowing-card', 'glow-dark');
                                    } else {
                                        createManaMist(manaIcon, 'in', '#a78bfa');
                                        card3d.classList.add('arcane-recharge', 'glowing-card', 'glow-purple');
                                    }
                                }
                                localCharData.attributes.manaAtual = tableData.currentMana;
                                needsUpdate = true;
                            }

                            if (localCharData.dinheiro !== tableData.money) {
                                if (cardOnScreen) {
                                    playMp3Sound('money.mp3');
                                    const direction = tableData.money > localCharData.dinheiro ? 'in' : 'out';
                                    createManaMist(moneyIcon, direction, '#fcd34d');
                                    card3d.classList.add('star-container', 'glowing-card', 'glow-yellow');
                                }
                                localCharData.dinheiro = tableData.money;
                                needsUpdate = true;
                            }

                            if (cardOnScreen) {
                                triggerAnimation(card3d, 'animate');
                            }

                            // 3. Se algum valor mudou, salva no banco local e atualiza a UI
                            if (needsUpdate) {
                                await saveData(CARD_STORE_NAME, localCharData);
                                console.log(`Personagem "${localCharData.title}" sincronizado da mesa.`);

                                // 4. Verifica se o card atualizado é o que está sendo exibido na tela
                                const displayedCardElement = document.querySelector(`.rpg-card[data-card-id="${charId}"]`);
                                if (displayedCardElement) {
                                    // Se sim, atualiza os valores na interface gráfica
                                    updateCardUI(charId, tableData);
                                }
                            }
                        }
                    }
                });
            }
            /**
             * Atualiza a interface gráfica de um card específico com novos dados.
             * @param {string} cardId - O ID do card a ser atualizado.
             * @param {object} newData - Os novos dados (currentLife, currentMana, money).
             */
            function updateCardUI(cardId, newData) {
                const cardElement = document.querySelector(`.rpg-card[data-card-id="${cardId}"]`);
                if (!cardElement) return;

                // Seleciona os spans que exibem os valores
                const lifeSpan = cardElement.querySelector('span[data-status="life"]');
                const manaSpan = cardElement.querySelector('span[data-status="mana"]');
                const moneySpan = cardElement.querySelector('span[data-status="money"]');

                // Atualiza os textos e as barras de status
                if (lifeSpan) lifeSpan.textContent = newData.currentLife;
                if (manaSpan) manaSpan.textContent = newData.currentMana;
                if (moneySpan) moneySpan.textContent = newData.money;

                // Pega os valores máximos do card para calcular a porcentagem correta das barras
                const maxLife = parseInt(cardElement.querySelector('.heart-container span:last-child').textContent);
                const maxMana = parseInt(cardElement.querySelector('.potion-container span:last-child').textContent);

                updateHeartVisuals(newData.currentLife, maxLife);
                updatePotionVisuals(newData.currentMana, maxMana);
            }

            function createThumbnailElement(cardData, storeName) {
                const thumbContainer = document.createElement('div');
                thumbContainer.className = 'relative thumbnail-container';
                thumbContainer.style.minWidth = '5rem';
                const thumb = document.createElement('div');
                thumb.className = 'relative w-20 h-24 rounded-lg overflow-hidden shadow-lg border-2 border-gray-400 cursor-pointer hover:border-indigo-500 transition-colors duration-200';
                thumb.dataset.cardId = cardData.id;
                thumb.style.backgroundImage = `url(${cardData.backgroundURL})`;
                thumb.style.backgroundSize = 'cover';
                thumb.style.backgroundPosition = 'center';
                thumb.innerHTML = `<div class="absolute inset-0 bg-black bg-opacity-40 flex items-center justify-center"><img src="${cardData.imageURL}" onerror="this.src='https://placehold.co/40x40/E5E7EB/4B5563?text=P';" alt="Miniatura" class="w-10 h-10 object-cover rounded-full border-2 border-white"></div><div class="absolute bottom-1 left-1 bg-gray-800 text-white text-xs px-2 py-1 rounded-full font-bold">Lv.${cardData.level}</div>`;
                thumb.addEventListener('click', () => displayCard(cardData.id));
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'absolute -top-2 -right-2 flex flex-col gap-1 thumbnail-actions';
                actionsDiv.innerHTML = `
                    <button class="thumb-btn bg-gray-700 hover:bg-gray-600 thumb-btn-menu" data-action="toggle-menu" title="Menu"><i class="fas fa-ellipsis-v"></i></button>
                    <div class="thumbnail-menu">
                        <button data-action="edit" data-card-id="${cardData.id}" data-store="${storeName}"><i class="fas fa-pencil-alt"></i> Editar</button>
                        <button data-action="download-json" data-card-id="${cardData.id}" data-store="${storeName}"><i class="fas fa-file-code"></i> Baixar</button>
                        <button data-action="remove" data-card-id="${cardData.id}" data-store="${storeName}"><i class="fas fa-trash-alt"></i> Excluir</button>
                    </div>
                `;
                thumbContainer.appendChild(thumb);
                thumbContainer.appendChild(actionsDiv);
                return thumbContainer;
            }
            async function removeCard(cardId) {
                playMp3Sound("excluir.mp3");
                await removeData(CARD_STORE_NAME, cardId);
                await renderCardsAndThumbnails();
            }
            async function renderSpellCards() {
                spellThumbnailList.innerHTML = '';
                habThumbnailList.innerHTML = '';
                spellThumbnailList.appendChild(createAddThumbnail('spell'));

                const allSpells = await getData(SPELL_STORE_NAME);
                if (allSpells.length === 0) {
                    spellCardDisplayArea.innerHTML = '<p class="text-gray-400 text-center">Nenhuma magia ou habilidade pré-criada encontrada.Clique no botão + para criar uma.</p>';
                } else {
                    spellCardDisplayArea.innerHTML = '<p class="text-gray-400">Selecione uma magia ou habilidade na lista para ver os detalhes.</p>';
                }
                let spellsLoaded = 0;
                for (const spellData of allSpells) {
                    let imageURL = 'https://placehold.co/160x160/14b8a6/1f2937?text=Magia';
                    if (spellData.image) imageURL = URL.createObjectURL(bufferToBlob(spellData.image, spellData.imageMimeType));
                    const spellThumbnail = createSpellThumbnailElement({ ...spellData, imageURL });
                    if (spellData.type === 'magia') {
                        spellThumbnailList.appendChild(spellThumbnail);
                    }
                    else {
                        habThumbnailList.appendChild(spellThumbnail);
                    }
                    spellsLoaded++;
                    const percentage = 33 + Math.round((spellsLoaded / allSpells.length) * 33);
                    updateProgress(percentage, loadingMessages[Math.floor(Math.random() * loadingMessages.length)]);
                }
                if (allSpells.length > 0) {
                    await displaySpell(allSpells[0].id);
                }
            }
            async function displaySpell(spellId) {
                spellCardDisplayArea.innerHTML = '';
                const fullSpellData = await getData(SPELL_STORE_NAME, spellId);
                if (!fullSpellData) return;
                let imageURL = 'https://placehold.co/160x160/14b8a6/1f2937?text=Magia';
                if (fullSpellData.image) imageURL = URL.createObjectURL(bufferToBlob(fullSpellData.image, fullSpellData.imageMimeType));
                const spellCardElement = await createSpellCardElement({
                    ...fullSpellData,
                    imageURL
                });
                spellCardDisplayArea.appendChild(spellCardElement);
                setTimeout(() => spellCardElement.classList.add('visible'), 10);
            }

            async function createSpellCardElement(spellData) {
                const cardWrapper = document.createElement('div');
                cardWrapper.className = 'card-wrapper flex flex-col items-center gap-4';
                const cardDiv = document.createElement('div');
                cardDiv.className = 'w-full h-[700px] rounded-3xl shadow-2xl rpg-card relative';
                cardDiv.dataset.spellId = spellData.id;

                // Condição para verificar se é uma magia
                const isMagia = spellData.type === 'magia';

                let palette = {
                    cardBg: isMagia ? 'rgba(17, 24, 39, 0.9)' : 'rgba(29, 17, 39, 0.9)',
                    highlightColor: isMagia ? '#2dd4bf' : '#c084fc',
                    textColor: '#e5e7eb',
                    borderColor: isMagia ? '#0d9488' : '#a855f7'
                };

                var imgam = "";

                if (spellData.imageURL && !spellData.imageURL.includes('placehold.co')) {
                    try {
                        const newPalette = await getPredominantColorAndPalette(spellData.imageURL);
                        palette.borderColor = newPalette.borderColor;
                        palette.highlightColor = newPalette.highlightColor;
                    } catch (e) {
                        console.error('Falha ao gerar paleta para magia/habilidade.', e);
                    }
                }
                var imgIs = spellData.imageURL.includes('placehold.co');

                cardDiv.style.backgroundImage = !imgIs ? `url(${spellData.imageURL})` : 'url(backMagia.png)';
                cardDiv.style.backgroundColor = "rgb(0 0 0 / 50%)";
                cardDiv.style.backgroundBlendMode = "multiply";
                cardDiv.style.backgroundPosition = "center";

                cardDiv.style.border = `2px solid ${palette.borderColor}`;
                cardDiv.innerHTML = `
                    <div class="card-3d-container">
                        <div class="nebula-sky">
                          
                            <div class="card-3d">
                                <div class="card-front" style="background-image:${!imgIs ? `url(${spellData.imageURL})` : 'url(backMagia.png)'}; background-size: cover; background-position: center;">
                                <div class="parallax-container"  style="opacity: ${!imgIs ? '0' : '1'}">
                                    <div id="nebula-bg" class="stars-layer"   style="background: url(backMagia.png); background-size: contain;"></div>
                                    <div id="stars-far" class="stars-layer"></div>
                                    <div id="stars-medium" class="stars-layer"></div>
                                    <div id="stars-near" class="stars-layer"></div>
                                </div>
                                <div id="glow-overlay"></div>
                                    <div class="rounded-3xl relative w-full h-full p-4" style="background: linear-gradient(-180deg, #000000ba, #00000085,transparent, #00000085, #000000ba);">
                                        <div id="txtMagia" class="w-full h-full"  style=" display: flex; flex-direction: column; align-items: center; justify-content: space-between;">
                                            <div class="text-center w-full">
                                                <h3 class="text-2xl font-bold" style="color: ${palette.highlightColor};">${spellData.name}</h3>
                                                <div class="rpg-card-title-divider" style="background: linear-gradient(to right, transparent, ${palette.borderColor}, transparent); width: 100%"></div>
                                            </div>
                                            ${/* MODIFICAÇÃO AQUI: Adiciona o bloco de informações apenas se for magia */ ''}
                                            ${isMagia ? `
                                            <div class="text-xs text-gray-300 mb-3" style="position: absolute; margin-top: 55px; left: 15px;">
                                                <p class="text-left"><strong>Execução:</strong> ${spellData.execution || '-'}</p>
                                                <p class="text-left"><strong>Alcance:</strong> ${spellData.range || '-'}</p>
                                                <p class="text-left"><strong>Alvo:</strong> ${spellData.target || '-'}</p>
                                                <p class="text-left"><strong>Duração:</strong> ${spellData.duration || '-'}</p>
                                                <p class="text-left"><strong>Resistência:</strong> ${spellData.resistencia || '-'}</p>
                                            </div>
                                            ` : ''}
                                            <div class="w-full">
                                                <div class="scrollable-content text-sm text-left" style="display: flex; flex-direction: row; overflow-y: scroll;gap: 12px; scroll-snap-type: x mandatory;">
                                                    <div class="mb-4 p-3 rounded-3xl w-full" style="scroll-snap-align: start;flex-shrink: 0;min-width: 100%; border-color: ${palette.borderColor}; position: relative; z-index: 1; overflow-y: visible;">
                                                        <h4 class="font-semibold text-gray-300">Descrição</h4>
                                                        <p class="text-gray-300 text-xs" style="text-align:justify;white-space:pre-line;overflow-wrap:break-word;">${spellData.description || 'Nenhuma descrição.'}</p>
                                                    </div>
                                                    ${/* MODIFICAÇÃO AQUI: Adiciona os campos extras apenas se for magia */ ''}
                                                    ${isMagia ? `
                                                    <div class="mb-4 p-3 rounded-3xl w-full" style="scroll-snap-align: start;flex-shrink: 0;min-width: 100%; border-color: ${palette.borderColor}; position: relative; z-index: 1; overflow-y: visible;">
                                                        <h4 class="font-semibold text-gray-300">Aprimorar</h4>
                                                        <p class="text-gray-300 text-xs" style="text-align:justify;white-space:pre-line;overflow-wrap:break-word;">${spellData.enhance || 'Nenhuma descrição.'}</p>
                                                    </div>
                                                    <div class="p-3 rounded-3xl w-full" style="scroll-snap-align: start;flex-shrink: 0;flex-shrink: 0;min-width: 100%; border-color: ${palette.borderColor}; position: relative; z-index: 1; overflow-y: visible;">
                                                        <h4 class="font-semibold text-gray-300">Verdadeiro</h4>
                                                        <p class="text-gray-300 text-xs" style="text-align:justify;white-space:pre-line;overflow-wrap:break-word;">${spellData.true || 'Nenhuma descrição.'}</p>
                                                    </div>
                                                    ` : ''}
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div class="card-back" style="background-image:${!imgIs ? `url(${spellData.imageURL})` : 'url(backMagia.png)'}; background-size: cover; background-color: rgb(0 0 0 / 50%);background-blend-mode: multiply; background-position: center;">
                                    <div class="back-content p-4 text-left" style="display: flex; border: 5px solid ${palette.borderColor}; align-items: center; justify-content: center;">
                                    ${isMagia ? `<i class="fas fa-hat-wizard" style="font-size: 200px; opacity: .4;color: ${palette.borderColor}"></i>` : `<i class="fas fa-fist-raised" style="font-size: 200px; opacity: .4;color: ${palette.borderColor}"></i>`}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>`;
                const card3d = cardDiv.querySelector('.card-3d');



                if (card3d) {
                    card3d.addEventListener('click', (e) => {
                        card3d.style.transform =
                            card3d.style.transform === 'rotateY(180deg)' ? 'rotateY(0deg)' : 'rotateY(180deg)';
                    });
                }
                cardWrapper.appendChild(cardDiv);

                // --- INÍCIO DA SOLUÇÃO ---
                // Adicione este trecho para impedir que o parallax seja ativado na área de rolagem.
                const scrollableContent = cardDiv.querySelector('.scrollable-content');
                if (scrollableContent) {
                    // Para eventos de mouse (clicar e arrastar)
                    scrollableContent.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                    });
                    // Para eventos de toque em dispositivos móveis
                    scrollableContent.addEventListener('touchstart', (e) => {
                        e.stopPropagation();
                    });
                }
                // --- FIM DA SOLUÇÃO ---
                // --- ADICIONE ESTAS LINHAS NO FINAL DA FUNÇÃO ---
                const nebulaContainer = cardDiv.querySelector('.nebula-sky');
                if (nebulaContainer) {
                    initializeNebulaEffect(nebulaContainer);
                }
                return cardWrapper;
            }

            function createSpellThumbnailElement(spellData) {
                const thumbContainer = document.createElement('div');
                thumbContainer.className = 'relative thumbnail-container';
                thumbContainer.style.minWidth = '5rem';
                const thumb = document.createElement('div');
                const isMagia = spellData.type === 'magia';
                const borderColor = isMagia ? 'border-teal-500' : 'border-purple-500';
                const bgColor = isMagia ? `linear-gradient(45deg, #0f172a, #1e293b)` : `linear-gradient(45deg, #1e1b4b, #312e81)`;
                const icon = isMagia ? `<i class="fas fa-hat-wizard"></i>` : `<i class="fas fa-fist-raised"></i>`;

                thumb.className = `relative w-20 h-24 rounded-lg overflow-hidden shadow-lg border-2 border-gray-400 cursor-pointer hover:${borderColor} transition-colors duration-200`;
                thumb.dataset.spellId = spellData.id;
                thumb.style.background = `${bgColor}, url(${spellData.imageURL})`;
                thumb.style.backgroundSize = 'cover';
                thumb.style.backgroundPosition = 'center';
                thumb.style.backgroundBlendMode = 'multiply';
                thumb.style.minWidth = '5rem';
                thumb.innerHTML = `
                    <div class="absolute inset-0 bg-black bg-opacity-50 flex flex-col items-center justify-center p-1 text-center">
                        <img src="${spellData.imageURL}" onerror="this.src='https://placehold.co/40x40/14b8a6/1f2937?text=M';" alt="Miniatura" class="w-10 h-10 object-cover rounded-full border-2 ${isMagia ? 'border-teal-400' : 'border-purple-400'} mb-1">
                        <p class="text-white text-[10px] font-bold leading-tight" style="text-shadow: 1px 1px 2px black; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; width: 75%;">${spellData.name}</p>
                    </div>
                    <div class="type-icon">${icon}</div>
                `;
                thumb.addEventListener('click', () => displaySpell(spellData.id));
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'absolute -top-2 -right-2 flex flex-col gap-1 thumbnail-actions';
                actionsDiv.innerHTML = `
                    <button class="thumb-btn bg-gray-700 hover:bg-gray-600 thumb-btn-menu" data-action="toggle-menu" title="Menu"><i class="fas fa-ellipsis-v"></i></button>
                    <div class="thumbnail-menu">
                        <button data-action="edit" data-card-id="${spellData.id}" data-store="${SPELL_STORE_NAME}"><i class="fas fa-pencil-alt"></i> Editar</button>
                        <button data-action="download-json" data-card-id="${spellData.id}" data-store="${SPELL_STORE_NAME}"><i class="fas fa-file-code"></i> Baixar JSON</button>
                        <button data-action="remove" data-card-id="${spellData.id}" data-store="${SPELL_STORE_NAME}"><i class="fas fa-trash-alt"></i> Excluir</button>
                    </div>
                `;
                thumbContainer.appendChild(thumb);
                thumbContainer.appendChild(actionsDiv);
                return thumbContainer;
            }
            async function editSpell(spellId) {
                const spellData = await getData(SPELL_STORE_NAME, spellId);
                if (!spellData) return;
                showSpellCreationView(true);
                spellFormTitle.textContent = `Editando: ${spellData.name}`;
                currentEditingSpellId = spellId;
                document.getElementById('spellType').value = spellData.type || 'magia';
                document.getElementById('spellName').value = spellData.name;
                document.getElementById('spellExecution').value = spellData.execution;
                document.getElementById('spellRange').value = spellData.range;
                document.getElementById('spellTarget').value = spellData.target;
                document.getElementById('spellDuration').value = spellData.duration;
                document.getElementById('spellResistencia').value = spellData.resistencia;
                document.getElementById('spellDescription').value = spellData.description;
                document.getElementById('spellEnhance').value = spellData.enhance;
                document.getElementById('spellTrue').value = spellData.true;
                if (spellData.image) {
                    const imageBlob = bufferToBlob(spellData.image, spellData.imageMimeType);
                    showImagePreview(spellImagePreview, URL.createObjectURL(imageBlob), true);
                    spellImageFile = null;
                } else {
                    showImagePreview(spellImagePreview, null, true);
                }
                spellImageUpload.value = null;
                spellSubmitButton.textContent = 'Salvar Edição';
            }
            async function removeSpell(spellId) {
                playMp3Sound("excluir.mp3");
                await removeData(SPELL_STORE_NAME, spellId);
                const allCards = await getData(CARD_STORE_NAME);
                for (const card of allCards) {
                    if (card.spells && card.spells.includes(spellId)) {
                        card.spells = card.spells.filter(id => id !== spellId);
                        await saveData(CARD_STORE_NAME, card);
                    }
                }
                await renderSpellCards();
                const displayedCard = document.querySelector('.rpg-card[data-card-id]');
                if (displayedCard) {
                    await updateSidebarsContent(displayedCard, displayedCard.dataset.cardId);
                }
            }

            async function renderItemsAndThumbnails() {
                itemThumbnailList.innerHTML = '';
                itemThumbnailList.appendChild(createAddThumbnail('item'));
                const allItems = await getData(ITEM_STORE_NAME);
                if (allItems.length === 0) {
                    itemCardDisplayArea.innerHTML = '<p class="text-gray-400 text-center">Nenhum item pré-criado encontrado.Clique no botão + para criar um.</p>';
                } else {
                    itemCardDisplayArea.innerHTML = '<p class="text-gray-400">Selecione um item na lista acima para ver os detalhes.</p>';
                }
                let itemsLoaded = 0;
                for (const itemData of allItems) {
                    let imageURL = 'https://placehold.co/160x160/f59e0b/422006?text=Item';
                    if (itemData.image) imageURL = URL.createObjectURL(bufferToBlob(itemData.image, itemData.imageMimeType));
                    const itemThumbnail = createItemThumbnailElement({
                        ...itemData,
                        imageURL
                    });
                    itemThumbnailList.appendChild(itemThumbnail);
                    itemsLoaded++;
                    const percentage = 66 + Math.round((itemsLoaded / allItems.length) * 34);
                    updateProgress(percentage, loadingMessages[Math.floor(Math.random() * loadingMessages.length)]);
                }
                if (allItems.length > 0) {
                    await displayItem(allItems[0].id);
                }
            }
            async function displayItem(itemId) {
                itemCardDisplayArea.innerHTML = '';
                const fullItemData = await getData(ITEM_STORE_NAME, itemId);
                if (!fullItemData) return;
                let imageURL = 'https://placehold.co/160x160/f59e0b/422006?text=Item';
                if (fullItemData.image) imageURL = URL.createObjectURL(bufferToBlob(fullItemData.image, fullItemData.imageMimeType));
                const itemCardElement = await createItemCardElement({
                    ...fullItemData,
                    imageURL
                });
                itemCardDisplayArea.appendChild(itemCardElement);
                setTimeout(() => itemCardElement.classList.add('visible'), 10);
            }
            async function createItemCardElement(itemData) {
                const cardWrapper = document.createElement('div');
                cardWrapper.className = 'card-wrapper flex flex-col items-center gap-4';
                const cardDiv = document.createElement('div');
                cardDiv.className = 'w-full h-[700px] rounded-3xl shadow-2xl rpg-card relative';
                cardDiv.dataset.itemId = itemData.id;
                let palette = {
                    cardBg: 'rgba(17, 24, 39, 0.9)',
                    highlightColor: '#f59e0b',
                    textColor: '#e5e7eb',
                    borderColor: '#d97706'
                };
                if (itemData.imageURL && !itemData.imageURL.includes('placehold.co')) {
                    try {
                        palette = await getPredominantColorAndPalette(itemData.imageURL);
                    } catch (e) {
                        console.error('Falha ao gerar paleta para item.', e);
                    }
                }

                var imgIs = itemData.imageURL.includes('placehold.co');
                cardDiv.style.backgroundImage = !imgIs ? `url(${itemData.imageURL})` : 'url(backItens.png)';
                cardDiv.style.backgroundColor = "rgb(0 0 0 / 50%)";
                cardDiv.style.backgroundBlendMode = "multiply";
                cardDiv.style.backgroundPosition = "center";

                cardDiv.style.border = `2px solid ${palette.borderColor}`;
                cardDiv.innerHTML = `
                <div class="card-3d-container">
                    <div class="nebula-sky">                       
                        <div class="card-3d">
                            <div class="card-front" style="background-image:${!imgIs ? `url(${itemData.imageURL})` : 'url(backItens.png)'}; background-size: cover; background-position: center; background-position: center;">
                                 <div class="parallax-container" style="opacity: ${!imgIs ? '0' : '1'}">
                            <div id="nebula-bg" class="stars-layer" style="background: url(backItens.png); background-size: contain; background-position: center;"></div>
                            <div id="stars-far" class="stars-layer"></div>
                            <div id="stars-medium" class="stars-layer"></div>
                            <div id="stars-near" class="stars-layer"></div>
                            <div id="milky-way"></div>
                        </div>
                        <div id="glow-overlay"></div>
                                <div class="rounded-3xl relative w-full h-full p-4" style="background: linear-gradient(-180deg, #000000ba, #00000085, transparent, #00000085, #000000ba);">
                                   <div id="txtItem" class="w-full h-full" style="display: flex; flex-direction: column; align-items: center; justify-content: space-between;"> 
                                    <div class="text-center w-full">
                                        <h3 class="text-2xl font-bold" style="color: ${palette.highlightColor};">${itemData.name}</h3>
                                        <div class="rpg-card-title-divider" style="background: linear-gradient(to right, transparent, ${palette.borderColor}, transparent); width: 100%"></div>
                                    </div>
                                    <div class="text-xs text-gray-300 mb-3 w-full px-2" style="position: absolute; margin-top: 55px; text-align:justify;">
                                        <p><strong>Tipo:</strong> ${itemData.type || '-'}</p>
                                        <p><strong>Dano:</strong> ${itemData.damage || '-'}</p>
                                        <p><strong>Carga:</strong> ${itemData.charge}</p>
                                        <p><strong>Pré-requisito:</strong> ${itemData.prerequisite || '-'}</p>
                                        <p><strong>Restaurar Vida:</strong> ${itemData.restoreLife || 0} PV</p>
                                        <p><strong>Restaurar Mana:</strong> ${itemData.restoreMana || 0} PM</p>
                                        <p><strong>Usável:</strong> ${itemData.usable ? 'Sim' : 'Não'}</p>
                                    </div>
                                    <div class="w-full p-2" style="text-align:justify;">
                                        <p class="text-xs text-gray-300 italic">Efeito</p>
                                        <p class="text-xs text-gray-300 italic" style="text-align:justify;white-space:pre-line;overflow-wrap:break-word;">${itemData.effect || 'Nenhum efeito.'}</p>
                                    </div>
                                  </div>  
                                </div>
                            </div>
                            <div class="card-back" style="background-image:${!imgIs ? `url(${itemData.imageURL})` : 'url(backItens.png)'}; background-size: cover; background-color: rgb(0 0 0 / 50%);background-blend-mode: multiply;background-position: center;">
                                <div class="back-content p-4 text-left" style="display: flex; border: 5px solid ${palette.borderColor}; align-items: center; justify-content: center;">
                                <i class="fas fa-box" style="font-size: 200px; opacity: .4;color: ${palette.borderColor}"></i>  
                                </div>
                            </div>
                        </div>
                    </div>
                </div>`;
                const card3d = cardDiv.querySelector('.card-3d');
                if (card3d) {
                    card3d.addEventListener('click', (e) => {
                        card3d.style.transform = card3d.style.transform === 'rotateY(180deg)' ? 'rotateY(0deg)' : 'rotateY(180deg)';
                    });
                }
                cardWrapper.appendChild(cardDiv);

                // --- INÍCIO DA SOLUÇÃO ---
                // Adicione este trecho para impedir que o parallax seja ativado na área de rolagem.
                const scrollableContent = cardDiv.querySelector('.scrollable-content');
                if (scrollableContent) {
                    // Para eventos de mouse (clicar e arrastar)
                    scrollableContent.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                    });
                    // Para eventos de toque em dispositivos móveis
                    scrollableContent.addEventListener('touchstart', (e) => {
                        e.stopPropagation();
                    });
                }
                // --- FIM DA SOLUÇÃO ---
                // --- ADICIONE ESTAS LINHAS NO FINAL DA FUNÇÃO ---
                const nebulaContainer = cardDiv.querySelector('.nebula-sky');
                if (nebulaContainer) {
                    initializeNebulaEffect(nebulaContainer);
                }

                return cardWrapper;
            }

            function createItemThumbnailElement(itemData) {
                const thumbContainer = document.createElement('div');
                thumbContainer.className = 'relative thumbnail-container';
                thumbContainer.style.minWidth = '5rem';
                const thumb = document.createElement('div');
                thumb.className = 'relative w-20 h-24 rounded-lg overflow-hidden shadow-lg border-2 border-gray-400 cursor-pointer hover:border-amber-500 transition-colors duration-200';
                thumb.dataset.itemId = itemData.id;
                thumb.style.background = `linear-gradient(45deg, #272011, #422006), url(${itemData.imageURL})`;
                thumb.style.backgroundSize = 'cover';
                thumb.style.backgroundPosition = 'center';
                thumb.style.backgroundBlendMode = 'multiply';
                thumb.style.minWidth = '5rem';
                thumb.innerHTML = `
                    <div class="absolute inset-0 bg-black bg-opacity-50 flex flex-col items-center justify-center p-1 text-center">
                        <img src="${itemData.imageURL}" onerror="this.src='https://placehold.co/40x40/f59e0b/422006?text=I';" alt="Miniatura do Item" class="w-10 h-10 object-cover rounded-full border-2 border-amber-400 mb-1">
                        <p class="text-white text-[10px] font-bold leading-tight" style="text-shadow: 1px 1px 2px black; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; width: 75%;">${itemData.name}</p>
                        <p class="text-amber-300 text-[9px] font-semibold">Carga: ${itemData.charge}</p>
                    </div>`;
                thumb.addEventListener('click', () => displayItem(itemData.id));
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'absolute -top-2 -right-2 flex flex-col gap-1 thumbnail-actions';
                actionsDiv.innerHTML = `
                    <button class="thumb-btn bg-gray-700 hover:bg-gray-600 thumb-btn-menu" data-action="toggle-menu" title="Menu"><i class="fas fa-ellipsis-v"></i></button>
                    <div class="thumbnail-menu">
                        <button data-action="edit" data-card-id="${itemData.id}" data-store="${ITEM_STORE_NAME}"><i class="fas fa-pencil-alt"></i> Editar</button>
                        <button data-action="download-json" data-card-id="${itemData.id}" data-store="${ITEM_STORE_NAME}"><i class="fas fa-file-code"></i> Baixar JSON</button>
                        <button data-action="remove" data-card-id="${itemData.id}" data-store="${ITEM_STORE_NAME}"><i class="fas fa-trash-alt"></i> Excluir</button>
                    </div>
                `;
                thumbContainer.appendChild(thumb);
                thumbContainer.appendChild(actionsDiv);
                return thumbContainer;
            }

            async function editItem(itemId) {
                const itemData = await getData(ITEM_STORE_NAME, itemId);
                if (!itemData) return;
                showItemCreationView(true);
                itemFormTitle.textContent = `Editando: ${itemData.name}`;
                currentEditingItemId = itemId;
                document.getElementById('itemName').value = itemData.name;
                document.getElementById('itemType').value = itemData.type;
                document.getElementById('itemDamage').value = itemData.damage;
                document.getElementById('itemCharge').value = itemData.charge;
                document.getElementById('itemPrerequisite').value = itemData.prerequisite;
                document.getElementById('itemEffect').value = itemData.effect;
                document.getElementById('itemRestoreLife').value = itemData.restoreLife || 0;
                document.getElementById('itemRestoreMana').value = itemData.restoreMana || 0;
                document.getElementById('itemUsable').value = itemData.usable ? 'true' : 'false';
                if (itemData.image) {
                    const imageBlob = bufferToBlob(itemData.image, itemData.imageMimeType);
                    showImagePreview(itemImagePreview, URL.createObjectURL(imageBlob), true);
                    itemImageFile = null;
                } else {
                    showImagePreview(itemImagePreview, null, true);
                }
                itemImageUpload.value = null;
                itemSubmitButton.textContent = 'Salvar Edição';

                // ADICIONE AS DUAS LINHAS ABAIXO
                updateItemFormVisibility();
                handleRestoreInputs();
            }

            async function removeItem(itemId) {
                playMp3Sound("excluir.mp3");
                await removeData(ITEM_STORE_NAME, itemId);
                const allCards = await getData(CARD_STORE_NAME);
                for (const card of allCards) {
                    if (card.items && card.items.includes(itemId)) {
                        card.items = card.items.filter(id => id !== itemId);
                        await saveData(CARD_STORE_NAME, card);
                    }
                }
                await renderItemsAndThumbnails();
                const displayedCard = document.querySelector('.rpg-card[data-card-id]');
                if (displayedCard) {
                    await updateSidebarsContent(displayedCard, displayedCard.dataset.cardId);
                }
            }
            characterImageUpload.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    characterImageFile = file;
                    showImagePreview(characterImagePreview, URL.createObjectURL(file), true);
                }
            });
            backgroundImageUpload.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    backgroundImageFile = file;
                    showImagePreview(backgroundImagePreview, URL.createObjectURL(file), false);
                }
            });
            spellImageUpload.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    spellImageFile = file;
                    showImagePreview(spellImagePreview, URL.createObjectURL(file), true);
                }
            });
            itemImageUpload.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    itemImageFile = file;
                    showImagePreview(itemImagePreview, URL.createObjectURL(file), true);
                }
            });

            function showImagePreview(element, url, isImageElement) {
                if (url) {
                    if (isImageElement) element.src = url;
                    else element.style.backgroundImage = `url(${url})`;
                    element.classList.remove('hidden');
                } else {
                    element.classList.add('hidden');
                }
            }

            function readFileAsArrayBuffer(file) {
                return new Promise((resolve, reject) => {
                    if (!file) {
                        resolve(null);
                        return;
                    }
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = (e) => reject(e.target.error);
                    reader.readAsArrayBuffer(file);
                });
            }
            cardForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const selectedPericias = [];
                const periciaCheckboxes = document.querySelectorAll('#pericias-checkboxes-container input[type="checkbox"]:checked');
                periciaCheckboxes.forEach(cb => {
                    const periciaName = cb.value;
                    const periciaId = `pericia-${periciaName.replace(/\s+/g, '-')}`;
                    const valueInput = document.getElementById(`${periciaId}-value`);
                    const periciaClass = Object.keys(periciasData)
                        .find(key => periciasData[key][periciaName]);
                    selectedPericias.push({
                        name: periciaName,
                        value: parseInt(valueInput.value) || 0,
                        class: periciaClass
                    });
                });
                const attributes = {
                    vida: parseInt(vidaInput.value) || 0,
                    mana: parseInt(manaInput.value) || 0,
                    vidaAtual: parseInt(vidaAtualInput.value) || 0,
                    manaAtual: parseInt(manaAtualInput.value) || 0,
                    armadura: parseInt(armaduraInput.value) || 0,
                    esquiva: parseInt(esquivaInput.value) || 0,
                    bloqueio: parseInt(bloqueioInput.value) || 0,
                    deslocamento: parseInt(deslocamentoInput.value) || 0,
                    agilidade: parseInt(agilidadeInput.value) || 0,
                    carisma: parseInt(carismaInput.value) || 0,
                    forca: parseInt(forcaInput.value) || 0,
                    inteligencia: parseInt(inteligenciaInput.value) || 0,
                    sabedoria: parseInt(sabedoriaInput.value) || 0,
                    vigor: parseInt(vigorInput.value) || 0,
                    pericias: selectedPericias
                };
                const lore = {
                    historia: historiaInput.value,
                    personalidade: personalidadeInput.value,
                    motivacao: motivacaoInput.value
                };
                let cardData;
                if (currentEditingCardId) {
                    cardData = await getData(CARD_STORE_NAME, currentEditingCardId);
                    if (!cardData) return;
                    Object.assign(cardData, {
                        title: cardTitleInput.value,
                        subTitle: cardSubTitleInput.value,
                        level: parseInt(cardLevelInput.value) || 1,
                        dinheiro: parseInt(dinheiroInput.value) || 0,
                        attributes,
                        lore
                    });
                } else {
                    cardData = {
                        id: Date.now().toString(),
                        title: cardTitleInput.value,
                        subTitle: cardSubTitleInput.value,
                        level: parseInt(cardLevelInput.value) || 1,
                        dinheiro: parseInt(dinheiroInput.value) || 0,
                        attributes,
                        lore,
                        items: [],
                        spells: []
                    };
                }
                if (characterImageFile) {
                    const compressedBlob = await compressImage(characterImageFile, {
                        quality: 0.75,
                        maxWidth: 400
                    });
                    cardData.image = await compressedBlob.arrayBuffer();
                    cardData.imageMimeType = compressedBlob.type;
                }
                if (backgroundImageFile) {
                    const compressedBlob = await compressImage(backgroundImageFile, {
                        quality: 0.7,
                        maxWidth: 1024
                    });
                    cardData.backgroundImage = await compressedBlob.arrayBuffer();
                    cardData.backgroundMimeType = compressedBlob.type;
                }
                await saveData(CARD_STORE_NAME, cardData);
                cardForm.reset();
                characterImageFile = null;
                backgroundImageFile = null;
                showImagePreview(characterImagePreview, null, true);
                showImagePreview(backgroundImagePreview, null, false);
                currentEditingCardId = null;
                await renderCardsAndThumbnails();
                showDisplayView();
            });
            spellForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                let spellData;
                const spellDetails = {
                    type: document.getElementById('spellType').value,
                    name: document.getElementById('spellName').value,
                    execution: document.getElementById('spellExecution').value,
                    range: document.getElementById('spellRange').value,
                    target: document.getElementById('spellTarget').value,
                    duration: document.getElementById('spellDuration').value,
                    resistencia: document.getElementById('spellResistencia').value,
                    description: document.getElementById('spellDescription').value,
                    enhance: document.getElementById('spellEnhance').value,
                    true: document.getElementById('spellTrue').value
                };
                if (currentEditingSpellId) {
                    spellData = await getData(SPELL_STORE_NAME, currentEditingSpellId);
                    if (!spellData) return;
                    Object.assign(spellData, spellDetails);
                } else {
                    spellData = {
                        id: Date.now()
                            .toString(),
                        ...spellDetails
                    };
                }
                if (spellImageFile) {
                    const compressedBlob = await compressImage(spellImageFile, {
                        quality: 0.75,
                        maxWidth: 400
                    });
                    spellData.image = await compressedBlob.arrayBuffer();
                    spellData.imageMimeType = compressedBlob.type;
                }
                await saveData(SPELL_STORE_NAME, spellData);
                spellForm.reset();
                spellImageFile = null;
                currentEditingSpellId = null;
                showImagePreview(spellImagePreview, null, true);
                await renderSpellCards();
                showSpellDisplayView();
            });
            itemForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                let itemData;
                const itemValues = {
                    name: document.getElementById('itemName').value,
                    type: document.getElementById('itemType').value,
                    damage: document.getElementById('itemDamage').value,
                    charge: parseInt(document.getElementById('itemCharge').value) || 0,
                    prerequisite: document.getElementById('itemPrerequisite').value,
                    effect: document.getElementById('itemEffect').value,
                    restoreLife: parseInt(document.getElementById('itemRestoreLife').value) || 0,
                    restoreMana: parseInt(document.getElementById('itemRestoreMana').value) || 0,
                    usable: document.getElementById('itemUsable').value === 'true'
                };
                if (currentEditingItemId) {
                    itemData = await getData(ITEM_STORE_NAME, currentEditingItemId);
                    if (!itemData) return;
                    Object.assign(itemData, itemValues);
                } else {
                    itemData = {
                        id: Date.now()
                            .toString(),
                        ...itemValues
                    };
                }
                if (itemImageFile) {
                    const compressedBlob = await compressImage(itemImageFile, {
                        quality: 0.75,
                        maxWidth: 400
                    });
                    itemData.image = await compressedBlob.arrayBuffer();
                    itemData.imageMimeType = compressedBlob.type;
                }
                await saveData(ITEM_STORE_NAME, itemData);
                itemForm.reset();
                itemImageFile = null;
                currentEditingItemId = null;
                showImagePreview(itemImagePreview, null, true);
                await renderItemsAndThumbnails();
                showItemDisplayView();
            });
            async function showExpandedCardInModal(data, type, characterId = null) {
                const existingContainer = document.querySelector('.expanded-card-container');
                if (existingContainer) existingContainer.remove();
                const expandedContainer = document.createElement('div');
                expandedContainer.className = 'expanded-card-container';
                const cardHolder = document.createElement('div');
                cardHolder.className = 'expanded-card';
                let cardWrapper;
                let imageURL;
                if (type === 'spell') {
                    imageURL = 'https://placehold.co/160x160/14b8a6/1f2937?text=Magia';
                    if (data.image) imageURL = URL.createObjectURL(bufferToBlob(data.image, data.imageMimeType));
                    cardWrapper = await createSpellCardElement({
                        ...data,
                        imageURL
                    });
                } else {
                    imageURL = 'https://placehold.co/160x160/f59e0b/422006?text=Item';
                    if (data.image) imageURL = URL.createObjectURL(bufferToBlob(data.image, data.imageMimeType));
                    cardWrapper = await createItemCardElement({
                        ...data,
                        imageURL
                    });
                }
                const cardItself = cardWrapper.querySelector('.rpg-card');
                const closeButton = document.createElement('button');
                closeButton.innerHTML = '&times;';
                closeButton.className = 'absolute top-4 right-6 text-white text-4xl z-50 font-bold hover:text-red-500 transition-colors';
                closeButton.onclick = () => {
                    expandedContainer.classList.remove('visible');
                    expandedContainer.addEventListener('transitionend', () => expandedContainer.remove(), {
                        once: true
                    });
                };
                if (cardItself) {
                    cardHolder.appendChild(cardItself);
                    cardHolder.appendChild(closeButton);
                    if (type === 'item' && characterId && data.usable) {
                        const useButton = document.createElement('button');
                        useButton.textContent = 'Usar';
                        useButton.className = 'absolute top-1/2 -translate-x-1/2 py-3 px-4 text-lg font-bold text-white bg-green-600 hover:bg-green-700 transition-colors z-50 btn-usar';
                        useButton.onclick = () => {
                            useItem(data.id, characterId);
                        };
                        cardHolder.appendChild(useButton);
                    }
                }
                expandedContainer.appendChild(cardHolder);
                document.body.appendChild(expandedContainer);
                setTimeout(() => expandedContainer.classList.add('visible'), 10);
                expandedContainer.addEventListener('click', function (event) {
                    if (event.target === expandedContainer) {
                        expandedContainer.classList.remove('visible');
                        expandedContainer.addEventListener('transitionend', () => expandedContainer.remove(), {
                            once: true
                        });
                    }
                });
            }
            async function updateSidebarsContent(cardElement, characterId) {
                if (!cardElement) return;
                const character = await getData(CARD_STORE_NAME, characterId);
                if (!character) return;
                const allMasterSpells = await getData(SPELL_STORE_NAME);
                const allMasterItems = await getData(ITEM_STORE_NAME);
                const spellsMap = new Map(allMasterSpells.map(s => [s.id, s]));
                const itemsMap = new Map(allMasterItems.map(i => [i.id, i]));
                const spellContentDiv = cardElement.querySelector("#spell-sidebar-content");
                spellContentDiv.innerHTML = '';
                if (!character.spells || character.spells.length === 0) {
                    spellContentDiv.innerHTML = `<p class="text-xs text-gray-500 w-full text-center self-center">Vazio.</p>`;
                } else {
                    character.spells.forEach(spellId => {
                        const spellData = spellsMap.get(spellId);
                        if (!spellData) return;
                        let imageURL = 'https://placehold.co/60x60/14b8a6/1f2937?text=M';
                        if (spellData.image) imageURL = URL.createObjectURL(bufferToBlob(spellData.image, spellData.imageMimeType));
                        const itemEl = document.createElement('div');
                        itemEl.className = 'sidebar-item';
                        itemEl.dataset.templateId = spellId;
                        itemEl.dataset.type = 'spell';
                        itemEl.innerHTML = `<img src="${imageURL}" alt="${spellData.name}"><p>${spellData.name}</p>`;
                        spellContentDiv.appendChild(itemEl);
                    });
                }
                const itemContentDiv = cardElement.querySelector("#item-sidebar-content");
                itemContentDiv.innerHTML = '';
                if (!character.items || character.items.length === 0) {
                    itemContentDiv.innerHTML = `<p class="text-xs text-gray-500 w-full text-center self-center">Vazio.</p>`;
                } else {
                    const itemCounts = character.items.reduce((acc, id) => {
                        acc[id] = (acc[id] || 0) + 1;
                        return acc;
                    }, {});
                    Object.entries(itemCounts)
                        .forEach(([itemId, quantity]) => {
                            const itemData = itemsMap.get(itemId);
                            if (!itemData) return;
                            let imageURL = 'https://placehold.co/60x60/f59e0b/422006?text=I';
                            if (itemData.image) imageURL = URL.createObjectURL(bufferToBlob(itemData.image, itemData.imageMimeType));
                            const itemEl = document.createElement('div');
                            itemEl.className = 'sidebar-item';
                            itemEl.dataset.templateId = itemId;
                            itemEl.dataset.type = 'item';
                            itemEl.innerHTML = `
                            <img src="${imageURL}" alt="${itemData.name}">
                            <p>${itemData.name}</p>
                            ${quantity > 1 ? `<span class="absolute top-0 right-0 bg-red-600 text-white text-xs font-bold rounded-full h-5 w-5 flex items-center justify-center">${quantity}</span>` :
                                    ''}
                        `;
                            itemContentDiv.appendChild(itemEl);
                        });
                }
            }
            document.addEventListener('click', async (e) => {
                const menuButton = e.target.closest('.thumb-btn-menu');
                const activeMenu = document.querySelector('.thumbnail-menu-active');
                if (activeMenu && !activeMenu.contains(e.target) && !menuButton) {
                    activeMenu.remove();
                    return;
                }
                if (menuButton) {
                    if (activeMenu && activeMenu.dataset.ownerId === menuButton.parentElement.id) {
                        activeMenu.remove();
                        return;
                    }
                    if (activeMenu) {
                        activeMenu.remove();
                    }
                    const menuTemplate = menuButton.nextElementSibling;
                    if (menuTemplate && menuTemplate.classList.contains('thumbnail-menu')) {
                        const newMenu = menuTemplate.cloneNode(true);
                        newMenu.classList.add('thumbnail-menu-active');
                        newMenu.style.display = 'block';
                        if (!menuButton.parentElement.id) {
                            menuButton.parentElement.id = `thumb-action-${Date.now()}`;
                        }
                        newMenu.dataset.ownerId = menuButton.parentElement.id;
                        document.body.appendChild(newMenu);
                        const btnRect = menuButton.getBoundingClientRect();
                        const menuRect = newMenu.getBoundingClientRect();
                        newMenu.style.position = 'fixed';
                        newMenu.style.zIndex = '2000';
                        let leftPos = btnRect.right - menuRect.width;
                        if (leftPos < 10) {
                            leftPos = btnRect.left;
                        }
                        newMenu.style.left = `${leftPos}px`;
                        let topPos = btnRect.bottom + 5;
                        if (topPos + menuRect.height > window.innerHeight) {
                            topPos = btnRect.top - menuRect.height - 5;
                        }
                        newMenu.style.top = `${topPos}px`;
                    }
                    return;
                }
                const actionButton = e.target.closest('.thumbnail-menu-active button');
                if (actionButton) {
                    const action = actionButton.dataset.action;
                    const cardId = actionButton.dataset.cardId;
                    const storeName = actionButton.dataset.store;
                    if (!action || !cardId || !storeName) return;
                    switch (action) {
                        case 'edit':
                            if (storeName === CARD_STORE_NAME) await editCard(cardId);
                            if (storeName === SPELL_STORE_NAME) await editSpell(cardId);
                            if (storeName === ITEM_STORE_NAME) await editItem(cardId);
                            break;
                        case 'download-json':
                            await downloadCardAsJson(storeName, cardId);
                            break;
                        case 'remove':
                            if (storeName === CARD_STORE_NAME) await removeCard(cardId);
                            if (storeName === SPELL_STORE_NAME) await removeSpell(cardId);
                            if (storeName === ITEM_STORE_NAME) await removeItem(cardId);
                            break;
                    }
                    actionButton.closest('.thumbnail-menu-active')
                        .remove();
                }
            });

            cardDisplayArea.addEventListener('click', async (e) => {
                const actionElement = e.target.closest('[data-action]');
                const cardElement = e.target.closest('.rpg-card');
                if (!cardElement || !actionElement) return;
                const cardId = cardElement.dataset.cardId;
                const action = actionElement.dataset.action;
                if (action === 'open-status-modal') {
                    const local = actionElement.dataset.local;
                    openStatusModal(cardId, local);
                } else if (action === 'toggle-lore') {
                    const loreCard = cardElement.querySelector('.lore-card');
                    if (loreCard) loreCard.classList.toggle('visible');
                } else if (action === 'manage-inventory') {
                    playMp3Sound("ziper.mp3");
                    await showLinkViewForCharacter(cardId, 'inventory');
                } else if (action === 'manage-spells') {
                    playMp3Sound("ziper.mp3");
                    await showLinkViewForCharacter(cardId,
                        'spells');
                }
            });
            async function openStatusModal(cardId, local) {
                const cardData = await getData(CARD_STORE_NAME, cardId);
                if (!cardData) return;
                currentStatusEditingCardId = cardId;
                modalVidaAtualInput.value = cardData.attributes.vidaAtual || 0;
                modalManaAtualInput.value = cardData.attributes.manaAtual || 0;
                modalDinheiroInput.value = cardData.dinheiro ||
                    0;
                modalVidaAtualInput.max = cardData.attributes.vida;
                modalManaAtualInput.max = cardData.attributes.mana;
                vidaInputContainer.classList.add('hidden');
                manaInputContainer.classList.add('hidden');
                dinheiroInputContainer.classList.add('hidden');
                if (local === 'life') {
                    vidaInputContainer.classList.remove('hidden');
                } else if (local === 'mana') {
                    manaInputContainer.classList.remove('hidden');
                } else if (local === 'money') {
                    dinheiroInputContainer.classList.remove('hidden');
                }
                statusModal.classList.remove('hidden');
            }

          statusForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    if (!currentStatusEditingCardId) return;

    const cardData = await getData(CARD_STORE_NAME, currentStatusEditingCardId);
    if (!cardData) return;

    const cardOnScreen = document.querySelector(`.rpg-card[data-card-id="${currentStatusEditingCardId}"]`);
    const animationDuration = 500;

    const oldLife = cardData.attributes.vidaAtual;
    const oldMana = cardData.attributes.manaAtual;
    const oldMoney = cardData.dinheiro;

    const newLife = parseInt(modalVidaAtualInput.value);
    const newMana = parseInt(modalManaAtualInput.value);
    const newMoney = parseInt(modalDinheiroInput.value);

    // 1. Aciona as animações imediatamente
    if (cardOnScreen) {
        const vidaIcon = cardOnScreen.querySelector('.heart-container');
        const manaIcon = cardOnScreen.querySelector('.potion-container');
        const moneyIcon = cardOnScreen.querySelector('.money-container');
        const card3d = cardOnScreen.querySelector('.nebula-sky');
        resetcard3d(card3d);

        if (newLife !== oldLife) {
            if (newLife < oldLife) {
                triggerCardPunch(card3d);
            } else {
                triggerCardLifeIn(card3d, vidaIcon);
            }
        }
        if (newMana !== oldMana) {
            playMp3Sound('mana.mp3');
            if (newMana < oldMana) {
                createManaMist(manaIcon, 'out', '#1a1a1a');
                card3d.classList.add('star-container', 'glowing-card', 'glow-dark');
            } else {
                createManaMist(manaIcon, 'in', '#a78bfa');
                card3d.classList.add('arcane-recharge', 'glowing-card', 'glow-purple');
                createRuneEffect(card3d);
                setTimeout(() => {
                    const rune = card3d.querySelector('.rune-container');
                    if (rune) rune.remove();
                }, 2500);
            }
        }
        if (newMoney !== oldMoney) {
            playMp3Sound('money.mp3');
            const direction = newMoney > oldMoney ? 'in' : 'out';
            createManaMist(moneyIcon, direction, '#fcd34d');
            card3d.classList.add('star-container', 'glowing-card', 'glow-yellow');
        }
        triggerAnimation(card3d, 'animate');
        animateValue(cardOnScreen.querySelector('span[data-status="life"]'), oldLife, newLife, animationDuration);
        animateValue(cardOnScreen.querySelector('span[data-status="mana"]'), oldMana, newMana, animationDuration);
        animateValue(cardOnScreen.querySelector('span[data-status="money"]'), oldMoney, newMoney, animationDuration);
    }

    // Fecha o modal imediatamente
    statusModal.classList.add('hidden');

    // 2. Espera as animações terminarem (a mais longa é 2500ms) antes de salvar
    setTimeout(async () => {
        // Atualiza os dados no objeto local
        cardData.attributes.vidaAtual = newLife;
        cardData.attributes.manaAtual = newMana;
        cardData.dinheiro = newMoney;

        // Salva os dados localmente no IndexedDB
        await saveData(CARD_STORE_NAME, cardData);

        // VERIFICA SE O CARD ESTÁ NA MESA ANTES DE SINCRONIZAR COM O FIREBASE
        if (charactersOnTableIds.has(currentStatusEditingCardId)) {
            const updatesForTable = {
                currentLife: newLife,
                currentMana: newMana,
                money: newMoney
            };
            // Chama a função para sincronizar com a mesa
            await updateCharacterOnTable(currentStatusEditingCardId, updatesForTable);
        }

        // Atualiza as barras de status após a animação dos números
        updateHeartVisuals(cardData.attributes.vidaAtual, cardData.attributes.vida);
        updatePotionVisuals(cardData.attributes.manaAtual, cardData.attributes.mana);

        currentStatusEditingCardId = null;
    }, 2600); // Atraso de 2.6 segundos
});
          
            statusModalCloseBtn.addEventListener('click', () => {
                statusModal.classList.add('hidden');
                currentStatusEditingCardId = null;
            });

            function animateValue(obj, start, end, duration) {
                if (!obj) return;
                let startTimestamp = null;
                const step = (timestamp) => {
                    if (!startTimestamp) startTimestamp = timestamp;
                    const progress = Math.min((timestamp - startTimestamp) / duration, 1);
                    obj.innerHTML = Math.floor(progress * (end - start) + start);
                    if (progress < 1) {
                        window.requestAnimationFrame(step);
                    }
                };
                window.requestAnimationFrame(step);
            }
            async function useItem(templateId, characterId) {
                if (!templateId || !characterId) return;
                const itemToUse = await getData(ITEM_STORE_NAME, templateId);
                const character = await getData(CARD_STORE_NAME, characterId);
                if (!itemToUse || !character) return;
                const cardOnScreen = document.querySelector(`.rpg-card[data-card-id="${characterId}"]`);
                if (!cardOnScreen) return;
                const card3d = cardOnScreen.querySelector('.nebula-sky');
                resetcard3d(card3d);
                card3d.classList.add('spill-container', 'glowing-card', 'glow-potion');
                createPotionEffect(4, card3d);
                triggerAnimation(card3d, 'animate');
                const expandedItemModal = document.querySelector('.expanded-card-container');
                if (expandedItemModal) expandedItemModal.remove();
                const spellSidebar = cardOnScreen.querySelector('#spell-sidebar');
                if (spellSidebar) spellSidebar.classList.remove('expanded');
                const itemSidebar = cardOnScreen.querySelector('#item-sidebar');
                if (itemSidebar) itemSidebar.classList.remove('expanded');
                const POTION_ANIMATION_DURATION = 4000;
                const POUR_START_TIME = 1400;
                setTimeout(() => {
                    playMp3Sound('liquido.mp3');
                }, POUR_START_TIME);
                setTimeout(async () => {
                    resetcard3d(card3d);
                    let characterWasUpdated = false;
                    const animationDuration = 1000;
                    const cardFront = cardOnScreen.querySelector('.card-front');
                    if (itemToUse.restoreLife > 0) {
                        let currentLife = parseInt(character.attributes.vidaAtual) || 0;
                        const maxLife = parseInt(character.attributes.vida) || 0;
                        let newLife = Math.min(currentLife + parseInt(itemToUse.restoreLife), maxLife);
                        if (cardFront) {
                            animateValue(cardFront.querySelector('span[data-status="life"]'), currentLife,
                                newLife, animationDuration);
                        }
                        character.attributes.vidaAtual = newLife;
                        characterWasUpdated = true;
                    }
                    if (itemToUse.restoreMana > 0) {
                        let currentMana =
                            parseInt(character.attributes.manaAtual) || 0;
                        const maxMana = parseInt(character.attributes.mana) || 0;
                        let newMana = Math.min(currentMana + parseInt(itemToUse.restoreMana), maxMana);
                        if (cardFront) {
                            animateValue(cardFront.querySelector('span[data-status="mana"]'), currentMana, newMana, animationDuration);
                        }
                        character.attributes.manaAtual = newMana;
                        characterWasUpdated = true;
                    }
                    const itemIndex = character.items.indexOf(templateId);
                    if (itemIndex > -1) {
                        character.items.splice(itemIndex, 1);
                        characterWasUpdated = true;
                    }
                    if (characterWasUpdated) {
                        await saveData(CARD_STORE_NAME, character);
                    }
                    await new Promise(resolve => setTimeout(resolve, animationDuration));
                    updateHeartVisuals(character.attributes.vidaAtual, character.attributes.vida);
                    updatePotionVisuals(character.attributes.manaAtual, character.attributes.mana);
                    if (cardOnScreen) {
                        await updateSidebarsContent(cardOnScreen, characterId);
                    }
                    playMp3Sound('magia.mp3');
                }, POTION_ANIMATION_DURATION);
            }
            async function renderInventoryManagement(characterId) {
                const character = await getData(CARD_STORE_NAME, characterId);
                if (!character) return;
                const allMasterItems = await getData(ITEM_STORE_NAME);
                const itemsMap = new Map(allMasterItems.map(i => [i.id, i]));
                const charItemsWithOriginalIndex = (character.items || [])
                    .map((id, index) => ({
                        ...itemsMap.get(id),
                        originalIndex: index
                    }))
                    .filter(item => item.id);
                const strength = parseInt(character.attributes.forca) || 0;
                const slotAddingItems = charItemsWithOriginalIndex.filter(item => item.charge < 0);
                const zeroChargeItems = charItemsWithOriginalIndex.filter(item => item.charge === 0);
                const regularItems = charItemsWithOriginalIndex.filter(item => item.charge > 0);
                const extraSlots = slotAddingItems.reduce((acc, item) => acc + Math.abs(item.charge), 0);
                let totalSlots = (strength * 5) + extraSlots;
                let slots = Array(totalSlots)
                    .fill({
                        state: 'available'
                    });
                let totalCharge = 0;
                let slotsToBlock = regularItems.reduce((acc, item) => acc + (item.charge > 1 ? item.charge - 1 : 0), 0);
                for (let i = totalSlots - 1; i >= 0 && slotsToBlock > 0; i--) {
                    slots[i] = {
                        state: 'blocked'
                    };
                    slotsToBlock--;
                }
                let itemIndex = 0;
                for (let i = 0; i < totalSlots && itemIndex < regularItems.length; i++) {
                    if (slots[i].state === 'available') {
                        const currentItem = regularItems[itemIndex];
                        slots[i] = {
                            state: 'occupied',
                            item: currentItem
                        };
                        totalCharge += currentItem.charge;
                        itemIndex++;
                    }
                }
                slotsInfo.textContent = `Força: ${strength} | Carga: ${totalCharge}/${totalSlots}`;
                specialEquipmentContainer.innerHTML = '';
                if (slotAddingItems.length > 0) {
                    slotAddingItems.forEach(item => {
                        const slot = document.createElement('div');
                        slot.className = 'slot slot-occupied';
                        slot.title = `Clique para remover "${item.name}"`;
                        let imageURL = 'https://placehold.co/60x60/d2a679/422006?text=B';
                        if (item.image) imageURL = URL.createObjectURL(bufferToBlob(item.image, item.imageMimeType));
                        slot.innerHTML = `<img src="${imageURL}" alt="${item.name}"><span class="slot-item-name">${item.name} (${item.charge})</span>`;
                        slot.addEventListener('click', () => unlinkItem(item.originalIndex));
                        specialEquipmentContainer.appendChild(slot);
                    });
                } else {
                    specialEquipmentContainer.innerHTML = '<p class="col-span-5 text-center text-xs text-gray-500">Nenhum equipamento especial.</p>';
                }
                itemSlotsContainer.innerHTML = '';
                slots.forEach(slotData => {
                    const slotEl = document.createElement('div');
                    slotEl.className = `slot slot-${slotData.state}`;
                    if (slotData.state === 'occupied') {
                        let imageURL = 'https://placehold.co/60x60/f59e0b/422006?text=I';
                        if (slotData.item.image) imageURL = URL.createObjectURL(bufferToBlob(slotData.item.image, slotData.item.imageMimeType));
                        slotEl.innerHTML = `<img src="${imageURL}" alt="${slotData.item.name}"><span class="slot-item-name">${slotData.item.name} (${slotData.item.charge})</span>`;
                        slotEl.title = `Clique para remover "${slotData.item.name}"`;
                        slotEl.addEventListener('click', () => unlinkItem(slotData.item.originalIndex));
                    }
                    itemSlotsContainer.appendChild(slotEl);
                });
                zeroChargeItemsContainer.innerHTML = '';
                if (zeroChargeItems.length > 0) {
                    zeroChargeItems.forEach(item => {
                        const slot = document.createElement('div');
                        slot.className = 'slot slot-occupied';
                        slot.title = `Clique para remover "${item.name}"`;
                        let imageURL = 'https://placehold.co/60x60/9ca3af/1f2937?text=0';
                        if (item.image) imageURL = URL.createObjectURL(bufferToBlob(item.image, item.imageMimeType));
                        slot.innerHTML = `<img src="${imageURL}" alt="${item.name}"><span class="slot-item-name">${item.name}</span>`;
                        slot.addEventListener('click', () => unlinkItem(item.originalIndex));
                        zeroChargeItemsContainer.appendChild(slot);
                    });
                } else {
                    zeroChargeItemsContainer.innerHTML = '<p class="col-span-5 text-center text-xs text-gray-500">Nenhum item de carga zero.</p>';
                }
            }
            async function linkItem(templateId) {
                const character = await getData(CARD_STORE_NAME, currentLinkingCharacterId);
                const itemToAdd = await getData(ITEM_STORE_NAME, templateId);
                if (!character || !itemToAdd) return;
                const inventoryStatus = await getInventoryStatus(character.id);
                if (itemToAdd.charge > 0 && itemToAdd.charge > inventoryStatus.availableSlots) {
                    showCustomAlert("Não há espaço suficiente no inventário para este item.");
                    return;
                }
                character.items = character.items || [];
                character.items.push(templateId);
                await saveData(CARD_STORE_NAME, character);
                await renderInventoryManagement(currentLinkingCharacterId);
                selectionModal.classList.add('hidden');
                playMp3Sound("itemColocando.mp3");
            }
            async function unlinkItem(itemIndexInCharacterArray) {
                const character = await getData(CARD_STORE_NAME, currentLinkingCharacterId);
                if (!character || !character.items) return;
                character.items.splice(itemIndexInCharacterArray, 1);
                await saveData(CARD_STORE_NAME, character);
                await renderInventoryManagement(currentLinkingCharacterId);
                playMp3Sound("itemColocando.mp3");
            }
            async function getInventoryStatus(characterId) {
                const character = await getData(CARD_STORE_NAME, characterId);
                if (!character) return {
                    totalSlots: 0,
                    availableSlots: 0
                };
                const allMasterItems = await getData(ITEM_STORE_NAME);
                const itemsMap = new Map(allMasterItems.map(i => [i.id, i]));
                const charItems = (character.items || [])
                    .map(id => itemsMap.get(id))
                    .filter(Boolean);
                const strength = parseInt(character.attributes.forca) || 0;
                const slotAddingItems = charItems.filter(item => item.charge < 0);
                const regularItems = charItems.filter(item => item.charge > 0);
                const extraSlots = slotAddingItems.reduce((acc, item) => acc + Math.abs(item.charge), 0);
                const totalSlots = (strength * 5) + extraSlots;
                const occupiedSlots = regularItems.length;
                const blockedSlots = regularItems.reduce((acc, item) => acc + (item.charge > 1 ? item.charge - 1 : 0), 0);
                const availableSlots = totalSlots - occupiedSlots - blockedSlots;
                return {
                    totalSlots,
                    availableSlots: Math.max(0, availableSlots)
                };
            }
            async function openItemSelectionModal() {
                modalTitle.textContent = "Selecione um Item para Adicionar";
                const masterItems = await getData(ITEM_STORE_NAME);
                const character = await getData(CARD_STORE_NAME, currentLinkingCharacterId);
                const inventoryStatus = await getInventoryStatus(currentLinkingCharacterId);
                const charItemCounts = (character.items || [])
                    .reduce((acc, id) => {
                        acc[id] = (acc[id] || 0) + 1;
                        return acc;
                    }, {});
                modalList.innerHTML = '';
                if (masterItems.length === 0) {
                    modalList.innerHTML = '<p class="text-gray-400">Nenhum item pré-criado disponível.</p>';
                } else {
                    masterItems.forEach(item => {
                        const countInInventory = charItemCounts[item.id] || 0;
                        const itemDiv = document.createElement('div');
                        itemDiv.className = 'modal-item p-2 rounded-md flex items-center justify-between gap-4';
                        itemDiv.dataset.itemId = item.id;
                        let imageURL = 'https://placehold.co/40x40/f59e0b/422006?text=I';
                        if (item.image) imageURL = URL.createObjectURL(bufferToBlob(item.image, item.imageMimeType));
                        const canFit = item.charge <= 0 || item.charge <= inventoryStatus.availableSlots;
                        itemDiv.innerHTML = `
                            <div class="flex items-center gap-4 flex-grow">
                                <img src="${imageURL}" class="w-10 h-10 rounded-md object-cover">
                                <div>
                                    <p class="font-bold">${item.name}</p>
                                    <p class="text-xs text-gray-400">Carga: ${item.charge}</p>
                                </div>
                            </div>
                            <div class="flex items-center gap-3">
                                ${countInInventory > 0 ?
                                `<span class="text-xs bg-gray-600 text-green-300 font-semibold px-2 py-1 rounded-full">No inv.: ${countInInventory}</span>` : ''}
                                ${!canFit ?
                                `<span class="text-xs text-red-400 font-semibold">Não cabe</span>` : ''}
                            </div>
                        `;
                        if (canFit) {
                            itemDiv.addEventListener('click', () => linkItem(item.id));
                        } else {
                            itemDiv.setAttribute('disabled', true);
                            itemDiv.classList.add('opacity-50', 'cursor-not-allowed');
                        }
                        modalList.appendChild(itemDiv);
                    });
                }
                selectionModal.classList.remove('hidden');
            }
            addItemBtn.addEventListener('click', openItemSelectionModal);
            modalCloseBtn.addEventListener('click', () => selectionModal.classList.add('hidden'));
            async function renderLinkedSpells(characterId) {
                linkedSpellsContainer.innerHTML = '';
                const character = await getData(CARD_STORE_NAME, characterId);
                if (!character || !character.spells || character.spells.length === 0) {
                    linkedSpellsContainer.innerHTML = '<p class="text-gray-500 text-sm w-full text-center col-span-5">Nenhuma magia ou habilidade vinculada.</p>';
                    return;
                }
                const allMasterSpells = await getData(SPELL_STORE_NAME);
                const spellsMap = new Map(allMasterSpells.map(s => [s.id, s]));
                character.spells.forEach((spellId, index) => {
                    const spell = spellsMap.get(spellId);
                    if (!spell) return;
                    const isMagia = spell.type === 'magia';
                    const spellCard = document.createElement('div');
                    spellCard.className = `slot slot-occupied ${isMagia ? 'is-magia' : 'is-habilidade'}`;
                    spellCard.title = `Clique para desvincular "${spell.name}"`;
                    let imageURL = 'https://placehold.co/48x48/14b8a6/1f2937?text=M';
                    if (spell.image) imageURL = URL.createObjectURL(bufferToBlob(spell.image, spell.imageMimeType));
                    const icon = isMagia ? `<i class="fas fa-hat-wizard"></i>` : `<i class="fas fa-fist-raised"></i>`;
                    spellCard.innerHTML = `
                        <img src="${imageURL}" alt="${spell.name}">
                        <p class="slot-item-name">${spell.name}</p>
                        <div class="type-icon">${icon}</div>
                    `;
                    spellCard.addEventListener('click', () => unlinkSpell(index));
                    linkedSpellsContainer.appendChild(spellCard);
                });
            }
            async function openSpellSelectionModal(type) {
                modalTitle.textContent = `Selecione uma ${type === 'magia' ?
                    'Magia' : 'Habilidade'} para Adicionar`;
                const masterSpells = (await getData(SPELL_STORE_NAME))
                    .filter(s => s.type === type);
                const character = await getData(CARD_STORE_NAME, currentLinkingCharacterId);
                const linkedSpellIds = new Set(character.spells || []);
                modalList.innerHTML = '';
                if (masterSpells.length === 0) {
                    modalList.innerHTML = `<p class="text-gray-400">Nenhuma ${type === 'magia' ?
                        'magia' : 'habilidade'} pré-criada disponível.</p>`;
                } else {
                    masterSpells.forEach(spell => {
                        const isAlreadyLinked = linkedSpellIds.has(spell.id);
                        const spellDiv = document.createElement('div');
                        spellDiv.className = 'modal-item p-2 rounded-md flex items-center justify-between gap-4';
                        spellDiv.dataset.spellId = spell.id;
                        let imageURL = 'https://placehold.co/40x40/14b8a6/1f2937?text=M';
                        if (spell.image) imageURL = URL.createObjectURL(bufferToBlob(spell.image, spell.imageMimeType));
                        spellDiv.innerHTML = `
                            <div class="flex items-center gap-4">
                                <img src="${imageURL}" class="w-10 h-10 rounded-md object-cover">
                                <p class="font-bold">${spell.name}</p>
                            </div>
                            ${isAlreadyLinked ? '<span class="text-xs text-gray-500">Já possui</span>' : ''}
                        `;
                        if (isAlreadyLinked) {
                            spellDiv.setAttribute('disabled', true);
                            spellDiv.classList.add('opacity-50', 'cursor-not-allowed');
                        } else {
                            spellDiv.addEventListener('click', () => linkSpell(spell.id));
                        }
                        modalList.appendChild(spellDiv);
                    });
                }
                selectionModal.classList.remove('hidden');
            }
            addSpellBtn.addEventListener('click', () => {
                const selectedType = addSpellTypeSelect.value;
                openSpellSelectionModal(selectedType);
            });
            async function linkSpell(templateId) {
                const character = await getData(CARD_STORE_NAME, currentLinkingCharacterId);
                if (!character) return;
                character.spells = character.spells || [];
                if (character.spells.includes(templateId)) {
                    selectionModal.classList.add('hidden');
                    return;
                }
                character.spells.push(templateId);
                await saveData(CARD_STORE_NAME, character);
                await renderLinkedSpells(currentLinkingCharacterId);
                selectionModal.classList.add('hidden');
                playMp3Sound("magiaAdd.mp3");
            }
            async function unlinkSpell(spellIndex) {
                const character = await getData(CARD_STORE_NAME, currentLinkingCharacterId);
                if (!character || !character.spells) return;
                character.spells.splice(spellIndex, 1);
                await saveData(CARD_STORE_NAME, character);
                await renderLinkedSpells(currentLinkingCharacterId);
                playMp3Sound("magiaAdd.mp3");
            }
            async function downloadCardAsJson(storeName, cardId) {
                const cardData = await getData(storeName, cardId);
                if (!cardData) {
                    console.error("Card not found for download");
                    return;
                }
                const dataToExport = {
                    ...cardData
                };
                if (cardData.image) {
                    dataToExport.imageBase64 = arrayBufferToBase64(cardData.image);
                }
                if (cardData.backgroundImage) {
                    dataToExport.backgroundImageBase64 = arrayBufferToBase64(cardData.backgroundImage);
                }
                delete dataToExport.image;
                delete dataToExport.backgroundImage;
                const jsonString = JSON.stringify(dataToExport, null, 2);
                const blob = new Blob([jsonString], {
                    type: 'application/json'
                });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const safeTitle = (dataToExport.title || dataToExport.name || 'card')
                    .replace(/\s+/g, '_') + "-" + storeName;
                a.download = `${safeTitle}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            function initiateImport(storeName) {
                currentStoreForImport = storeName;
                jsonImportInput.value = null;
                jsonImportInput.click();
            }

            jsonImportInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file || !currentStoreForImport) return;

                const reader = new FileReader();
                reader.onload = async (event) => {
                    try {
                        const importedData = JSON.parse(event.target.result);

                        if (typeof importedData !== 'object' || importedData === null) {
                            throw new Error("Arquivo JSON inválido.");
                        }

                        // Lógica aprimorada para importação de backup completo
                        if (currentStoreForImport === 'full_database') {

                            // 1. Criar mapas para relacionar IDs antigos com novos
                            const idMaps = {
                                [CARD_STORE_NAME]: new Map(),
                                [SPELL_STORE_NAME]: new Map(),
                                [ITEM_STORE_NAME]: new Map()
                            };

                            const generateNewId = () => Date.now().toString() + Math.random().toString(36).substr(2, 5);

                            // Preenche os mapas com novos IDs para cada item do backup
                            for (const storeName in idMaps) {
                                if (importedData[storeName]) {
                                    for (const item of importedData[storeName]) {
                                        idMaps[storeName].set(item.id, generateNewId());
                                    }
                                }
                            }

                            // 2. Processar e remapear os dados antes de salvar

                            // Itens e Magias (não têm dependências)
                            for (const storeName of [ITEM_STORE_NAME, SPELL_STORE_NAME]) {
                                if (importedData[storeName]) {
                                    for (const item of importedData[storeName]) {
                                        const oldId = item.id;
                                        item.id = idMaps[storeName].get(oldId); // Atualiza o ID do próprio item

                                        // Converte imagens de Base64 de volta para ArrayBuffer
                                        if (item.imageBase64) {
                                            item.image = base64ToArrayBuffer(item.imageBase64);
                                            delete item.imageBase64;
                                        }
                                        if (item.backgroundImageBase64) {
                                            item.backgroundImage = base64ToArrayBuffer(item.backgroundImageBase64);
                                            delete item.backgroundImageBase64;
                                        }

                                        await saveData(storeName, item);
                                    }
                                }
                            }

                            // Personagens (têm dependências de itens e magias)
                            if (importedData[CARD_STORE_NAME]) {
                                for (const char of importedData[CARD_STORE_NAME]) {
                                    const oldId = char.id;
                                    char.id = idMaps[CARD_STORE_NAME].get(oldId); // Atualiza o ID do personagem

                                    // Remapeia o array de itens com os novos IDs
                                    if (char.items && Array.isArray(char.items)) {
                                        char.items = char.items
                                            .map(oldItemId => idMaps[ITEM_STORE_NAME].get(oldItemId))
                                            .filter(Boolean); // .filter(Boolean) remove quaisquer IDs nulos/indefinidos
                                    }

                                    // Remapeia o array de magias com os novos IDs
                                    if (char.spells && Array.isArray(char.spells)) {
                                        char.spells = char.spells
                                            .map(oldSpellId => idMaps[SPELL_STORE_NAME].get(oldSpellId))
                                            .filter(Boolean);
                                    }

                                    // Converte imagens
                                    if (char.imageBase64) {
                                        char.image = base64ToArrayBuffer(char.imageBase64);
                                        delete char.imageBase64;
                                    }
                                    if (char.backgroundImageBase64) {
                                        char.backgroundImage = base64ToArrayBuffer(char.backgroundImageBase64);
                                        delete char.backgroundImageBase64;
                                    }

                                    await saveData(CARD_STORE_NAME, char);
                                }
                            }

                            showCustomAlert("Backup importado com sucesso! IDs foram atualizados.");

                        } else { // Lógica para importação de card individual (já existente e correta)
                            importedData.id = Date.now().toString();

                            if (importedData.imageBase64 && importedData.imageMimeType) {
                                importedData.image = base64ToArrayBuffer(importedData.imageBase64);
                                delete importedData.imageBase64;
                            }
                            if (importedData.backgroundImageBase64 && importedData.backgroundMimeType) {
                                importedData.backgroundImage = base64ToArrayBuffer(importedData.backgroundImageBase64);
                                delete importedData.backgroundImageBase64;
                            }
                            await saveData(currentStoreForImport, importedData);
                            showCustomAlert("Card importado com sucesso!");
                        }

                        // Atualiza todas as visualizações
                        await renderCardsAndThumbnails();
                        await renderSpellCards();
                        await renderItemsAndThumbnails();
                        showDisplayView();

                    } catch (error) {
                        console.error("Erro ao importar JSON:", error);
                        showCustomAlert("Erro ao importar o arquivo. Verifique se é um JSON válido.");
                    } finally {
                        currentStoreForImport = null;
                        jsonImportInput.value = null; // Limpa o input para permitir selecionar o mesmo arquivo novamente
                    }
                };
                reader.readAsText(file);
            });

            function showCustomAlert(message, type = 'error') {
                const alertBox = document.createElement('div');
                const bgColor = type === 'success' ? '#22c55e' : '#ef4444';
                alertBox.style.cssText = `
                    position: fixed;
                    top: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    padding: 12px 24px;
                    border-radius: 8px;
                    background-color: ${bgColor};
                    color: white;
                    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
                    z-index: 9999;
                    font-weight: bold;
                    opacity: 0;
                    transition: opacity 0.3s ease-in-out, top 0.3s ease-in-out;
                `;
                alertBox.textContent = message;
                document.body.appendChild(alertBox);
                setTimeout(() => {
                    alertBox.style.opacity = '1';
                    alertBox.style.top = '30px';
                }, 10);
                setTimeout(() => {
                    alertBox.style.opacity = '0';
                    alertBox.style.top = '20px';
                    alertBox.addEventListener('transitionend', () => alertBox.remove());
                }, 3000);
            }
            // Localize esta função no seu index.html

            async function initializeApp() {
                showSplash();
                try {
                    await openDatabase();
                    populatePericiasCheckboxes();
                    await renderCardsAndThumbnails();
                    await renderSpellCards();
                    await renderItemsAndThumbnails();

                    // ADICIONE ESTA LINHA AQUI
                    listenForTableUpdates(); // Inicia a sincronização com a mesa

                    showDisplayView();
                    setTimeout(hideSplash, 1000);
                } catch (e) {
                    console.error("Falha ao inicializar o app:", e);
                    hideSplash();
                }
            }
            initializeApp();

            function createPotionEffect(numberOfPulses, animationBox) {
                const svgNS = "http://www.w3.org/2000/svg";
                const container = document.createElement('div');
                container.className = 'potion-svg-container';
                const svg = document.createElementNS(svgNS, 'svg');
                svg.setAttribute('viewBox', '0 0 50 50');
                const defs = document.createElementNS(svgNS, 'defs');
                const clipPath = document.createElementNS(svgNS, 'clipPath');
                const clipPathId = `potion-mask-${Date.now()}`;
                clipPath.id = clipPathId;
                const clipPathPath = document.createElementNS(svgNS, 'path');
                clipPathPath.setAttribute('d', 'M18,15 V5 h14 v10 a17,17 0 1,1 -14,0 z');
                clipPath.appendChild(clipPathPath);
                defs.appendChild(clipPath);
                svg.appendChild(defs);
                const g = document.createElementNS(svgNS, 'g');
                g.setAttribute('clip-path', `url(#${clipPathId})`);
                const liquid = document.createElementNS(svgNS, 'rect');
                liquid.classList.add('potion-liquid');
                liquid.setAttribute('x', '8');
                liquid.setAttribute('y', '25');
                liquid.setAttribute('width', '34');
                liquid.setAttribute('height', '25');
                g.appendChild(liquid);
                const bubbleData = [{
                    cx: 20,
                    cy: 45,
                    r: 2.5
                }, {
                    cx: 28,
                    cy: 42,
                    r: 2
                }, {
                    cx: 33,
                    cy: 46,
                    r: 1.5
                }];
                bubbleData.forEach(data => {
                    const bubble = document.createElementNS(svgNS, 'circle');
                    bubble.classList.add('bubble');
                    bubble.setAttribute('cx', data.cx);
                    bubble.setAttribute('cy', data.cy);
                    bubble.setAttribute('r', data.r);
                    bubble.style.animationDelay = `${Math.random() * 2}s`;
                    g.appendChild(bubble);
                });
                svg.appendChild(g);
                const glass = document.createElementNS(svgNS, 'path');
                glass.classList.add('potion-glass');
                glass.setAttribute('d', 'M18,15 V5 h14 v10 a17,17 0 1,1 -14,0 z');
                svg.appendChild(glass);
                const cork = document.createElementNS(svgNS, 'rect');
                cork.classList.add('potion-cork');
                cork.setAttribute('x', '18');
                cork.setAttribute('y', '0');
                cork.setAttribute('width', '14');
                cork.setAttribute('height', '5');
                cork.setAttribute('rx', '2');
                svg.appendChild(cork);
                container.appendChild(svg);
                animationBox.appendChild(container);
                const stream = document.createElement('span');
                stream.className = 'potion-stream';
                animationBox.appendChild(stream);
                for (let i = 0; i < numberOfPulses; i++) {
                    const pulse = document.createElement('span');
                    pulse.className = 'potion-pulse';
                    pulse.style.animationDelay = `${2.1 + i * 0.3}s`;
                    animationBox.appendChild(pulse);
                }
            }
            async function downloadFullDatabase() {
                if (!db) return;
                const allData = {};
                const storeNames = [CARD_STORE_NAME, SPELL_STORE_NAME, ITEM_STORE_NAME];
                for (const storeName of storeNames) {
                    const data = await getData(storeName);
                    for (const entry of data) {
                        if (entry.image) entry.imageBase64 = arrayBufferToBase64(entry.image);
                        if (entry.backgroundImage) entry.backgroundImageBase64 = arrayBufferToBase64(entry.backgroundImage);
                        delete entry.image;
                        delete entry.backgroundImage;
                    }
                    allData[storeName] = data;
                }
                const jsonString = JSON.stringify(allData, null, 2);
                const blob = new Blob([jsonString], {
                    type: 'application/json'
                });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'rpg_card_creator_backup.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
            document.getElementById('downloadDbBtn')
                .addEventListener('click', downloadFullDatabase);

            async function openTakeFreeItemQuantityModal(key, cardData) {
                const buyModal = document.getElementById('buy-item-modal');
                const totalCostEl = document.getElementById('buy-total-cost').parentElement;
                const charSelectEl = document.getElementById('buy-character-select').parentElement;
                const buyQuantityInput = document.getElementById('buy-quantity');

                // Função para resetar o modal para o estado padrão de "compra" ao fechar
                const resetBuyModal = () => {
                    buyModal.querySelector('h3').textContent = 'Comprar Item';
                    totalCostEl.classList.remove('hidden');
                    charSelectEl.classList.remove('hidden');
                };

                // 1. Configura o modal para o modo "Pegar Gratuito"
                buyModal.querySelector('h3').textContent = 'Pegar Item Gratuito';
                document.getElementById('buy-item-name').textContent = cardData.name;
                document.getElementById('buy-item-price').innerHTML = `Preço: <span class="text-green-400 font-bold">Gratuito</span>`;

                // Esconde os elementos de pagamento
                totalCostEl.classList.add('hidden');
                charSelectEl.classList.add('hidden');

                // Preenche as informações do item
                let imageURL = 'https://placehold.co/128x128/1e293b/ffffff?text=?';
                if (cardData.imageBase64) {
                    imageURL = `data:${cardData.imageMimeType};base64,${cardData.imageBase64}`;
                }
                document.getElementById('buy-item-preview').innerHTML = `<img src="${imageURL}" class="w-full h-full object-cover rounded-lg">`;

                const availableQuantity = cardData.quantity;
                document.getElementById('buy-item-available').textContent = availableQuantity;
                buyQuantityInput.max = availableQuantity;
                buyQuantityInput.value = 1;

                // 2. Configura o botão de confirmação
                const confirmBtn = document.getElementById('confirm-buy-btn');
                const newConfirmBtn = confirmBtn.cloneNode(true); // Clona para limpar listeners antigos
                confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);

                newConfirmBtn.addEventListener('click', async () => {
                    const quantityToTake = parseInt(buyQuantityInput.value);
                    if (quantityToTake > 0 && quantityToTake <= availableQuantity) {
                        cardData.quantityToBuy = quantityToTake;
                        await takeCard(key, cardData);
                        buyModal.classList.add('hidden');
                        resetBuyModal(); // Reseta o modal ao confirmar
                    } else {
                        showCustomAlert("Quantidade inválida.");
                    }
                });

                // 3. Configura o botão de cancelar e exibe o modal
                const cancelBtn = document.getElementById('cancel-buy-btn');
                cancelBtn.onclick = () => {
                    buyModal.classList.add('hidden');
                    resetBuyModal(); // Reseta o modal ao cancelar
                };

                buyModal.classList.remove('hidden');
            }

           /**
 * Inicializa o efeito de paralaxe 3D para um contêiner de card,
 * adicionando controle tanto por mouse/toque quanto pelo acelerômetro do dispositivo.
 * @param {HTMLElement} container - O elemento .nebula-sky que contém as camadas do efeito.
 */
function initializeNebulaEffect(container) {
    if (!container) return;

    // Seleciona todos os elementos necessários para a animação
    const starsFar = container.querySelector('#stars-far');
    const starsMedium = container.querySelector('#stars-medium');
    const starsNear = container.querySelector('#stars-near');
    const glow = container.querySelector('#glow-overlay');
    const txtItem = container.querySelector('#txtItem');
    const txtMagia = container.querySelector('#txtMagia');

    // Validação para garantir que todos os elementos internos existem
    if (!starsFar || !starsMedium || !starsNear || !glow) {
        console.error("Elementos essenciais para o efeito de nebulosa não foram encontrados.");
        return;
    }

    const maxRotate = 20; // Rotação máxima do card em graus
    let isInteracting = false; // Flag para desativar o acelerômetro durante o arrastar manual

    // --- Lógica de Mouse e Toque (Arrastar) ---
    const factorFar = 0.02;
    const factorMedium = 0.04;
    const factorNear = 0.06;

    // Função que atualiza a rotação e a posição das camadas com base nas coordenadas
    const updateLayers = (x, y) => {
        const rotateY = (x / (container.offsetWidth / 2)) * maxRotate;
        const rotateX = -(y / (container.offsetHeight / 2)) * maxRotate;
        container.style.transform = `rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
        starsFar.style.transform = `translateZ(-40px) translate(${x * factorFar}px, ${y * factorFar}px)`;
        starsMedium.style.transform = `translateZ(-20px) translate(${x * factorMedium}px, ${y * factorMedium}px)`;
        if (txtItem) txtItem.style.transform = `translateZ(0px) translate(${x * factorNear}px, ${y * factorNear}px)`;
        if (txtMagia) txtMagia.style.transform = `translateZ(0px) translate(${x * factorNear}px, ${y * factorNear}px)`;
        starsNear.style.transform = `translateZ(0px) translate(${x * factorNear}px, ${y * factorNear}px)`;
    };

    const startInteraction = () => { isInteracting = true; container.style.transition = 'transform 0.1s linear'; };
    const moveInteraction = (e) => {
        if (!isInteracting) return;
        e.preventDefault();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const rect = container.getBoundingClientRect();
        const x = clientX - rect.left - rect.width / 2;
        const y = clientY - rect.top - rect.height / 2;
        updateLayers(x, y);
    };
    
    // --- FUNÇÃO ATUALIZADA ---
    // Agora, esta função reseta a posição do card ao soltar o mouse/toque.
    const endInteraction = () => {
        isInteracting = false;
        container.style.transition = 'transform 0.4s ease-out';
        
        // Reseta a rotação do card principal para a posição neutra
        container.style.transform = `rotateX(0deg) rotateY(0deg)`;
        
        // Reseta a posição das camadas internas para o centro
        starsFar.style.transform = `translateZ(-40px) translate(0px, 0px)`;
        starsMedium.style.transform = `translateZ(-20px) translate(0px, 0px)`;
        starsNear.style.transform = `translateZ(0px) translate(0px, 0px)`;
        if (txtItem) txtItem.style.transform = `translateZ(0px) translate(0px, 0px)`;
        if (txtMagia) txtMagia.style.transform = `translateZ(0px) translate(0px, 0px)`;
    };

    // Adiciona os listeners para mouse e toque
    container.addEventListener('mousedown', startInteraction);
    container.addEventListener('mousemove', moveInteraction);
    container.addEventListener('mouseup', endInteraction);
    container.addEventListener('mouseleave', endInteraction);
    container.addEventListener('touchstart', startInteraction);
    container.addEventListener('touchmove', moveInteraction);
    container.addEventListener('touchend', endInteraction);
    container.addEventListener('touchcancel', endInteraction);

    // --- Lógica do Acelerômetro (Inclinação) ---
    const handleOrientation = (event) => {
        if (isInteracting) return; // Não executa se o usuário estiver arrastando o card

        const gamma = event.gamma; // Inclinação esquerda/direita (-90 a 90)
        const beta = event.beta;   // Inclinação frente/trás (-180 a 180)

        // Limita os valores de inclinação para um movimento mais suave e controlado
        const clampedGamma = Math.max(-45, Math.min(45, gamma));
        const clampedBeta = Math.max(-45, Math.min(45, beta));

        // Converte a inclinação em rotação para o card
        const rotateY = (clampedGamma / 45) * maxRotate;
        const rotateX = (clampedBeta / 45) * -maxRotate;
        
        container.style.transition = 'transform 0.1s linear'; // Transição rápida para responsividade
        container.style.transform = `rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
        
        // Movimenta as camadas internas com base na inclinação para criar o efeito 3D
        const x = (clampedGamma / 45) * (container.offsetWidth / 4);
        const y = (clampedBeta / 45) * (container.offsetHeight / 4);
        starsFar.style.transform = `translateZ(-40px) translate(${x * factorFar}px, ${y * factorFar}px)`;
        starsMedium.style.transform = `translateZ(-20px) translate(${x * factorMedium}px, ${y * factorMedium}px)`;
        if (txtItem) txtItem.style.transform = `translateZ(0px) translate(${x * factorNear}px, ${y * factorNear}px)`;
        if (txtMagia) txtMagia.style.transform = `translateZ(0px) translate(${x * factorNear}px, ${y * factorNear}px)`;
        starsNear.style.transform = `translateZ(0px) translate(${x * factorNear}px, ${y * factorNear}px)`;
    };

    // Verifica se o navegador suporta o evento e lida com as permissões necessárias
    if (window.DeviceOrientationEvent) {
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            // iOS 13+ requer um clique do usuário para pedir permissão
            const permissionButton = document.createElement('button');
            permissionButton.innerHTML = '<i class="fas fa-mobile-alt"></i> Ativar Controle por Movimento';
            permissionButton.className = 'permission-button';
            
            container.appendChild(permissionButton);

            permissionButton.addEventListener('click', (e) => {
                e.stopPropagation(); // Impede que o clique no botão ative outros eventos do card
                DeviceOrientationEvent.requestPermission()
                    .then(permissionState => {
                        if (permissionState === 'granted') {
                            window.addEventListener('deviceorientation', handleOrientation);
                            permissionButton.remove();
                        } else {
                            alert('Permissão para usar sensores de movimento foi negada.');
                            permissionButton.remove();
                        }
                    })
                    .catch(console.error);
            });
        } else {
            // Outros navegadores (como Chrome no Android) não precisam de permissão explícita
            window.addEventListener('deviceorientation', handleOrientation);
        }
    }
}

            async function updateCharacterOnTable(charId, updates) {
                // As constantes 'database', 'ref', e 'update' já são importadas do Firebase
                const { database, ref, update } = window.firebaseDB;

                // Cria a referência para o personagem específico na mesa
                const charOnTableRef = ref(database, `gameTables/default-table/characters/${charId}`);

                try {
                    // Usa a função 'update' para alterar apenas os campos especificados
                    // Isso evita apagar outros dados que possam existir no nó do personagem na mesa
                    await update(charOnTableRef, updates);
                    console.log(`Dados do personagem ${charId} atualizados na mesa.`);
                } catch (error) {
                    console.error("Falha ao atualizar o personagem na mesa:", error);
                    // Opcional: Mostrar um alerta para o usuário
                    showCustomAlert("Não foi possível sincronizar com a mesa.");
                }
            }
            // --- FIX ENDS HERE ---
            var IsMesa = false;
            // --- ADICIONE ESTA NOVA FUNÇÃO ---
            function updateSendToTableButtonState(charId) {
                const cardOnScreen = document.querySelector(`.rpg-card[data-card-id="${charId}"]`);
                if (!cardOnScreen) return;

                const sendBtn = cardOnScreen.querySelector('#send-to-table-btn');
                if (!sendBtn) return;

                // Se o ID do personagem está na nossa lista da mesa
                if (charactersOnTableIds.has(charId)) {
                    sendBtn.innerHTML = '<i class="fas fa-sign-out-alt" style="font-size: 25px;"></i>';
                    sendBtn.title = "Remover da Mesa";
                    sendBtn.classList.add('on-table'); // Classe para lógica e estilo
                    IsMesa = true;
                    console.log(IsMesa);
                } else {
                    sendBtn.innerHTML = '<i class="fas fa-dungeon" style="font-size: 25px;"></i>';
                    sendBtn.title = "Enviar para a Mesa";
                    sendBtn.classList.remove('on-table');
                    IsMesa = false;
                    console.log(IsMesa);
                }
            }
            // --- FIM DA NOVA FUNÇÃO ---
        });
    </script>
</body>


</html>


